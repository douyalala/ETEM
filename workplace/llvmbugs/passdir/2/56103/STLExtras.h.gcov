        -:    0:Source:/data1/lyj/llvm-compilers/be6af89f85ebd04646b5704301470f02b70a0447-src/llvm/include/llvm/ADT/STLExtras.h
        -:    0:Graph:/data1/lyj/llvm-compilers//be6af89f85ebd04646b5704301470f02b70a0447-build/lib/Option/CMakeFiles/LLVMOption.dir/OptTable.cpp.gcno
        -:    0:Data:/data1/lyj/llvm-compilers//be6af89f85ebd04646b5704301470f02b70a0447-build/lib/Option/CMakeFiles/LLVMOption.dir/OptTable.cpp.gcda
        -:    0:Runs:2
        -:    1://===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:///
        -:    9:/// \file
        -:   10:/// This file contains some templates that are useful if you are working with
        -:   11:/// the STL at all.
        -:   12:///
        -:   13:/// No library is required when using these functions.
        -:   14:///
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#ifndef LLVM_ADT_STLEXTRAS_H
        -:   18:#define LLVM_ADT_STLEXTRAS_H
        -:   19:
        -:   20:#include "llvm/ADT/Optional.h"
        -:   21:#include "llvm/ADT/STLArrayExtras.h"
        -:   22:#include "llvm/ADT/STLForwardCompat.h"
        -:   23:#include "llvm/ADT/STLFunctionalExtras.h"
        -:   24:#include "llvm/ADT/identity.h"
        -:   25:#include "llvm/ADT/iterator.h"
        -:   26:#include "llvm/ADT/iterator_range.h"
        -:   27:#include "llvm/Config/abi-breaking.h"
        -:   28:#include "llvm/Support/ErrorHandling.h"
        -:   29:#include <algorithm>
        -:   30:#include <cassert>
        -:   31:#include <cstddef>
        -:   32:#include <cstdint>
        -:   33:#include <cstdlib>
        -:   34:#include <functional>
        -:   35:#include <initializer_list>
        -:   36:#include <iterator>
        -:   37:#include <limits>
        -:   38:#include <memory>
        -:   39:#include <tuple>
        -:   40:#include <type_traits>
        -:   41:#include <utility>
        -:   42:
        -:   43:#ifdef EXPENSIVE_CHECKS
        -:   44:#include <random> // for std::mt19937
        -:   45:#endif
        -:   46:
        -:   47:namespace llvm {
        -:   48:
        -:   49:// Only used by compiler if both template types are the same.  Useful when
        -:   50:// using SFINAE to test for the existence of member functions.
        -:   51:template <typename T, T> struct SameType;
        -:   52:
        -:   53:namespace detail {
        -:   54:
        -:   55:template <typename RangeT>
        -:   56:using IterOfRange = decltype(std::begin(std::declval<RangeT &>()));
        -:   57:
        -:   58:template <typename RangeT>
        -:   59:using ValueOfRange = typename std::remove_reference<decltype(
        -:   60:    *std::begin(std::declval<RangeT &>()))>::type;
        -:   61:
        -:   62:} // end namespace detail
        -:   63:
        -:   64://===----------------------------------------------------------------------===//
        -:   65://     Extra additions to <type_traits>
        -:   66://===----------------------------------------------------------------------===//
        -:   67:
        -:   68:template <typename T> struct make_const_ptr {
        -:   69:  using type =
        -:   70:      typename std::add_pointer<typename std::add_const<T>::type>::type;
        -:   71:};
        -:   72:
        -:   73:template <typename T> struct make_const_ref {
        -:   74:  using type = typename std::add_lvalue_reference<
        -:   75:      typename std::add_const<T>::type>::type;
        -:   76:};
        -:   77:
        -:   78:namespace detail {
        -:   79:template <typename...> using void_t = void;
        -:   80:template <class, template <class...> class Op, class... Args> struct detector {
        -:   81:  using value_t = std::false_type;
        -:   82:};
        -:   83:template <template <class...> class Op, class... Args>
        -:   84:struct detector<void_t<Op<Args...>>, Op, Args...> {
        -:   85:  using value_t = std::true_type;
        -:   86:};
        -:   87:} // end namespace detail
        -:   88:
        -:   89:/// Detects if a given trait holds for some set of arguments 'Args'.
        -:   90:/// For example, the given trait could be used to detect if a given type
        -:   91:/// has a copy assignment operator:
        -:   92:///   template<class T>
        -:   93:///   using has_copy_assign_t = decltype(std::declval<T&>()
        -:   94:///                                                 = std::declval<const T&>());
        -:   95:///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;
        -:   96:template <template <class...> class Op, class... Args>
        -:   97:using is_detected = typename detail::detector<void, Op, Args...>::value_t;
        -:   98:
        -:   99:namespace detail {
        -:  100:template <typename Callable, typename... Args>
        -:  101:using is_invocable =
        -:  102:    decltype(std::declval<Callable &>()(std::declval<Args>()...));
        -:  103:} // namespace detail
        -:  104:
        -:  105:/// Check if a Callable type can be invoked with the given set of arg types.
        -:  106:template <typename Callable, typename... Args>
        -:  107:using is_invocable = is_detected<detail::is_invocable, Callable, Args...>;
        -:  108:
        -:  109:/// This class provides various trait information about a callable object.
        -:  110:///   * To access the number of arguments: Traits::num_args
        -:  111:///   * To access the type of an argument: Traits::arg_t<Index>
        -:  112:///   * To access the type of the result:  Traits::result_t
        -:  113:template <typename T, bool isClass = std::is_class<T>::value>
        -:  114:struct function_traits : public function_traits<decltype(&T::operator())> {};
        -:  115:
        -:  116:/// Overload for class function types.
        -:  117:template <typename ClassType, typename ReturnType, typename... Args>
        -:  118:struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {
        -:  119:  /// The number of arguments to this function.
        -:  120:  enum { num_args = sizeof...(Args) };
        -:  121:
        -:  122:  /// The result type of this function.
        -:  123:  using result_t = ReturnType;
        -:  124:
        -:  125:  /// The type of an argument to this function.
        -:  126:  template <size_t Index>
        -:  127:  using arg_t = typename std::tuple_element<Index, std::tuple<Args...>>::type;
        -:  128:};
        -:  129:/// Overload for class function types.
        -:  130:template <typename ClassType, typename ReturnType, typename... Args>
        -:  131:struct function_traits<ReturnType (ClassType::*)(Args...), false>
        -:  132:    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};
        -:  133:/// Overload for non-class function types.
        -:  134:template <typename ReturnType, typename... Args>
        -:  135:struct function_traits<ReturnType (*)(Args...), false> {
        -:  136:  /// The number of arguments to this function.
        -:  137:  enum { num_args = sizeof...(Args) };
        -:  138:
        -:  139:  /// The result type of this function.
        -:  140:  using result_t = ReturnType;
        -:  141:
        -:  142:  /// The type of an argument to this function.
        -:  143:  template <size_t i>
        -:  144:  using arg_t = typename std::tuple_element<i, std::tuple<Args...>>::type;
        -:  145:};
        -:  146:template <typename ReturnType, typename... Args>
        -:  147:struct function_traits<ReturnType (*const)(Args...), false>
        -:  148:    : public function_traits<ReturnType (*)(Args...)> {};
        -:  149:/// Overload for non-class function type references.
        -:  150:template <typename ReturnType, typename... Args>
        -:  151:struct function_traits<ReturnType (&)(Args...), false>
        -:  152:    : public function_traits<ReturnType (*)(Args...)> {};
        -:  153:
        -:  154:/// traits class for checking whether type T is one of any of the given
        -:  155:/// types in the variadic list.
        -:  156:template <typename T, typename... Ts>
        -:  157:using is_one_of = disjunction<std::is_same<T, Ts>...>;
        -:  158:
        -:  159:/// traits class for checking whether type T is a base class for all
        -:  160:///  the given types in the variadic list.
        -:  161:template <typename T, typename... Ts>
        -:  162:using are_base_of = conjunction<std::is_base_of<T, Ts>...>;
        -:  163:
        -:  164:namespace detail {
        -:  165:template <typename T, typename... Us> struct TypesAreDistinct;
        -:  166:template <typename T, typename... Us>
        -:  167:struct TypesAreDistinct
        -:  168:    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&
        -:  169:                                       TypesAreDistinct<Us...>::value> {};
        -:  170:template <typename T> struct TypesAreDistinct<T> : std::true_type {};
        -:  171:} // namespace detail
        -:  172:
        -:  173:/// Determine if all types in Ts are distinct.
        -:  174:///
        -:  175:/// Useful to statically assert when Ts is intended to describe a non-multi set
        -:  176:/// of types.
        -:  177:///
        -:  178:/// Expensive (currently quadratic in sizeof(Ts...)), and so should only be
        -:  179:/// asserted once per instantiation of a type which requires it.
        -:  180:template <typename... Ts> struct TypesAreDistinct;
        -:  181:template <> struct TypesAreDistinct<> : std::true_type {};
        -:  182:template <typename... Ts>
        -:  183:struct TypesAreDistinct
        -:  184:    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};
        -:  185:
        -:  186:/// Find the first index where a type appears in a list of types.
        -:  187:///
        -:  188:/// FirstIndexOfType<T, Us...>::value is the first index of T in Us.
        -:  189:///
        -:  190:/// Typically only meaningful when it is otherwise statically known that the
        -:  191:/// type pack has no duplicate types. This should be guaranteed explicitly with
        -:  192:/// static_assert(TypesAreDistinct<Us...>::value).
        -:  193:///
        -:  194:/// It is a compile-time error to instantiate when T is not present in Us, i.e.
        -:  195:/// if is_one_of<T, Us...>::value is false.
        -:  196:template <typename T, typename... Us> struct FirstIndexOfType;
        -:  197:template <typename T, typename U, typename... Us>
        -:  198:struct FirstIndexOfType<T, U, Us...>
        -:  199:    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};
        -:  200:template <typename T, typename... Us>
        -:  201:struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};
        -:  202:
        -:  203:/// Find the type at a given index in a list of types.
        -:  204:///
        -:  205:/// TypeAtIndex<I, Ts...> is the type at index I in Ts.
        -:  206:template <size_t I, typename... Ts>
        -:  207:using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;
        -:  208:
        -:  209:/// Helper which adds two underlying types of enumeration type.
        -:  210:/// Implicit conversion to a common type is accepted.
        -:  211:template <typename EnumTy1, typename EnumTy2,
        -:  212:          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,
        -:  213:                                          std::underlying_type_t<EnumTy1>>,
        -:  214:          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,
        -:  215:                                          std::underlying_type_t<EnumTy2>>>
        -:  216:constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {
        -:  217:  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);
        -:  218:}
        -:  219:
        -:  220://===----------------------------------------------------------------------===//
        -:  221://     Extra additions to <iterator>
        -:  222://===----------------------------------------------------------------------===//
        -:  223:
        -:  224:namespace adl_detail {
        -:  225:
        -:  226:using std::begin;
        -:  227:
        -:  228:template <typename ContainerTy>
        8:  229:decltype(auto) adl_begin(ContainerTy &&container) {
        8:  230:  return begin(std::forward<ContainerTy>(container));
        -:  231:}
        -:  232:
        -:  233:using std::end;
        -:  234:
        -:  235:template <typename ContainerTy>
        8:  236:decltype(auto) adl_end(ContainerTy &&container) {
        8:  237:  return end(std::forward<ContainerTy>(container));
        -:  238:}
        -:  239:
        -:  240:using std::swap;
        -:  241:
        -:  242:template <typename T>
        -:  243:void adl_swap(T &&lhs, T &&rhs) noexcept(noexcept(swap(std::declval<T>(),
        -:  244:                                                       std::declval<T>()))) {
        -:  245:  swap(std::forward<T>(lhs), std::forward<T>(rhs));
        -:  246:}
        -:  247:
        -:  248:} // end namespace adl_detail
        -:  249:
        -:  250:template <typename ContainerTy>
        8:  251:decltype(auto) adl_begin(ContainerTy &&container) {
        8:  252:  return adl_detail::adl_begin(std::forward<ContainerTy>(container));
        -:  253:}
        -:  254:
        -:  255:template <typename ContainerTy>
        8:  256:decltype(auto) adl_end(ContainerTy &&container) {
        8:  257:  return adl_detail::adl_end(std::forward<ContainerTy>(container));
        -:  258:}
        -:  259:
        -:  260:template <typename T>
        -:  261:void adl_swap(T &&lhs, T &&rhs) noexcept(
        -:  262:    noexcept(adl_detail::adl_swap(std::declval<T>(), std::declval<T>()))) {
        -:  263:  adl_detail::adl_swap(std::forward<T>(lhs), std::forward<T>(rhs));
        -:  264:}
        -:  265:
        -:  266:/// Test whether \p RangeOrContainer is empty. Similar to C++17 std::empty.
        -:  267:template <typename T>
        -:  268:constexpr bool empty(const T &RangeOrContainer) {
        -:  269:  return adl_begin(RangeOrContainer) == adl_end(RangeOrContainer);
        -:  270:}
        -:  271:
        -:  272:/// Returns true if the given container only contains a single element.
        -:  273:template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {
        -:  274:  auto B = std::begin(C), E = std::end(C);
        -:  275:  return B != E && std::next(B) == E;
        -:  276:}
        -:  277:
        -:  278:/// Return a range covering \p RangeOrContainer with the first N elements
        -:  279:/// excluded.
        -:  280:template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {
        -:  281:  return make_range(std::next(adl_begin(RangeOrContainer), N),
        -:  282:                    adl_end(RangeOrContainer));
        -:  283:}
        -:  284:
        -:  285:/// Return a range covering \p RangeOrContainer with the last N elements
        -:  286:/// excluded.
        -:  287:template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {
        -:  288:  return make_range(adl_begin(RangeOrContainer),
        -:  289:                    std::prev(adl_end(RangeOrContainer), N));
        -:  290:}
        -:  291:
        -:  292:// mapped_iterator - This is a simple iterator adapter that causes a function to
        -:  293:// be applied whenever operator* is invoked on the iterator.
        -:  294:
        -:  295:template <typename ItTy, typename FuncTy,
        -:  296:          typename ReferenceTy =
        -:  297:              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>
        -:  298:class mapped_iterator
        -:  299:    : public iterator_adaptor_base<
        -:  300:          mapped_iterator<ItTy, FuncTy>, ItTy,
        -:  301:          typename std::iterator_traits<ItTy>::iterator_category,
        -:  302:          std::remove_reference_t<ReferenceTy>,
        -:  303:          typename std::iterator_traits<ItTy>::difference_type,
        -:  304:          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
        -:  305:public:
        -:  306:  mapped_iterator(ItTy U, FuncTy F)
        -:  307:    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}
        -:  308:
        -:  309:  ItTy getCurrent() { return this->I; }
        -:  310:
        -:  311:  const FuncTy &getFunction() const { return F; }
        -:  312:
        -:  313:  ReferenceTy operator*() const { return F(*this->I); }
        -:  314:
        -:  315:private:
        -:  316:  FuncTy F;
        -:  317:};
        -:  318:
        -:  319:// map_iterator - Provide a convenient way to create mapped_iterators, just like
        -:  320:// make_pair is useful for creating pairs...
        -:  321:template <class ItTy, class FuncTy>
        -:  322:inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {
        -:  323:  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));
        -:  324:}
        -:  325:
        -:  326:template <class ContainerTy, class FuncTy>
        -:  327:auto map_range(ContainerTy &&C, FuncTy F) {
        -:  328:  return make_range(map_iterator(C.begin(), F), map_iterator(C.end(), F));
        -:  329:}
        -:  330:
        -:  331:/// A base type of mapped iterator, that is useful for building derived
        -:  332:/// iterators that do not need/want to store the map function (as in
        -:  333:/// mapped_iterator). These iterators must simply provide a `mapElement` method
        -:  334:/// that defines how to map a value of the iterator to the provided reference
        -:  335:/// type.
        -:  336:template <typename DerivedT, typename ItTy, typename ReferenceTy>
        -:  337:class mapped_iterator_base
        -:  338:    : public iterator_adaptor_base<
        -:  339:          DerivedT, ItTy,
        -:  340:          typename std::iterator_traits<ItTy>::iterator_category,
        -:  341:          std::remove_reference_t<ReferenceTy>,
        -:  342:          typename std::iterator_traits<ItTy>::difference_type,
        -:  343:          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
        -:  344:public:
        -:  345:  using BaseT = mapped_iterator_base;
        -:  346:
        -:  347:  mapped_iterator_base(ItTy U)
        -:  348:      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}
        -:  349:
        -:  350:  ItTy getCurrent() { return this->I; }
        -:  351:
        -:  352:  ReferenceTy operator*() const {
        -:  353:    return static_cast<const DerivedT &>(*this).mapElement(*this->I);
        -:  354:  }
        -:  355:};
        -:  356:
        -:  357:/// Helper to determine if type T has a member called rbegin().
        -:  358:template <typename Ty> class has_rbegin_impl {
        -:  359:  using yes = char[1];
        -:  360:  using no = char[2];
        -:  361:
        -:  362:  template <typename Inner>
        -:  363:  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);
        -:  364:
        -:  365:  template <typename>
        -:  366:  static no& test(...);
        -:  367:
        -:  368:public:
        -:  369:  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);
        -:  370:};
        -:  371:
        -:  372:/// Metafunction to determine if T& or T has a member called rbegin().
        -:  373:template <typename Ty>
        -:  374:struct has_rbegin : has_rbegin_impl<typename std::remove_reference<Ty>::type> {
        -:  375:};
        -:  376:
        -:  377:// Returns an iterator_range over the given container which iterates in reverse.
        -:  378:// Note that the container must have rbegin()/rend() methods for this to work.
        -:  379:template <typename ContainerTy>
        -:  380:auto reverse(ContainerTy &&C,
        -:  381:             std::enable_if_t<has_rbegin<ContainerTy>::value> * = nullptr) {
        -:  382:  return make_range(C.rbegin(), C.rend());
        -:  383:}
        -:  384:
        -:  385:// Returns an iterator_range over the given container which iterates in reverse.
        -:  386:// Note that the container must have begin()/end() methods which return
        -:  387:// bidirectional iterators for this to work.
        -:  388:template <typename ContainerTy>
        -:  389:auto reverse(ContainerTy &&C,
        -:  390:             std::enable_if_t<!has_rbegin<ContainerTy>::value> * = nullptr) {
        -:  391:  return make_range(std::make_reverse_iterator(std::end(C)),
        -:  392:                    std::make_reverse_iterator(std::begin(C)));
        -:  393:}
        -:  394:
        -:  395:/// An iterator adaptor that filters the elements of given inner iterators.
        -:  396:///
        -:  397:/// The predicate parameter should be a callable object that accepts the wrapped
        -:  398:/// iterator's reference type and returns a bool. When incrementing or
        -:  399:/// decrementing the iterator, it will call the predicate on each element and
        -:  400:/// skip any where it returns false.
        -:  401:///
        -:  402:/// \code
        -:  403:///   int A[] = { 1, 2, 3, 4 };
        -:  404:///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });
        -:  405:///   // R contains { 1, 3 }.
        -:  406:/// \endcode
        -:  407:///
        -:  408:/// Note: filter_iterator_base implements support for forward iteration.
        -:  409:/// filter_iterator_impl exists to provide support for bidirectional iteration,
        -:  410:/// conditional on whether the wrapped iterator supports it.
        -:  411:template <typename WrappedIteratorT, typename PredicateT, typename IterTag>
        -:  412:class filter_iterator_base
        -:  413:    : public iterator_adaptor_base<
        -:  414:          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,
        -:  415:          WrappedIteratorT,
        -:  416:          typename std::common_type<
        -:  417:              IterTag, typename std::iterator_traits<
        -:  418:                           WrappedIteratorT>::iterator_category>::type> {
        -:  419:  using BaseT = typename filter_iterator_base::iterator_adaptor_base;
        -:  420:
        -:  421:protected:
        -:  422:  WrappedIteratorT End;
        -:  423:  PredicateT Pred;
        -:  424:
        -:  425:  void findNextValid() {
        -:  426:    while (this->I != End && !Pred(*this->I))
        -:  427:      BaseT::operator++();
        -:  428:  }
        -:  429:
        -:  430:  // Construct the iterator. The begin iterator needs to know where the end
        -:  431:  // is, so that it can properly stop when it gets there. The end iterator only
        -:  432:  // needs the predicate to support bidirectional iteration.
        -:  433:  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,
        -:  434:                       PredicateT Pred)
        -:  435:      : BaseT(Begin), End(End), Pred(Pred) {
        -:  436:    findNextValid();
        -:  437:  }
        -:  438:
        -:  439:public:
        -:  440:  using BaseT::operator++;
        -:  441:
        -:  442:  filter_iterator_base &operator++() {
        -:  443:    BaseT::operator++();
        -:  444:    findNextValid();
        -:  445:    return *this;
        -:  446:  }
        -:  447:};
        -:  448:
        -:  449:/// Specialization of filter_iterator_base for forward iteration only.
        -:  450:template <typename WrappedIteratorT, typename PredicateT,
        -:  451:          typename IterTag = std::forward_iterator_tag>
        -:  452:class filter_iterator_impl
        -:  453:    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {
        -:  454:public:
        -:  455:  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
        -:  456:                       PredicateT Pred)
        -:  457:      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}
        -:  458:};
        -:  459:
        -:  460:/// Specialization of filter_iterator_base for bidirectional iteration.
        -:  461:template <typename WrappedIteratorT, typename PredicateT>
        -:  462:class filter_iterator_impl<WrappedIteratorT, PredicateT,
        -:  463:                           std::bidirectional_iterator_tag>
        -:  464:    : public filter_iterator_base<WrappedIteratorT, PredicateT,
        -:  465:                                  std::bidirectional_iterator_tag> {
        -:  466:  using BaseT = typename filter_iterator_impl::filter_iterator_base;
        -:  467:
        -:  468:  void findPrevValid() {
        -:  469:    while (!this->Pred(*this->I))
        -:  470:      BaseT::operator--();
        -:  471:  }
        -:  472:
        -:  473:public:
        -:  474:  using BaseT::operator--;
        -:  475:
        -:  476:  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
        -:  477:                       PredicateT Pred)
        -:  478:      : BaseT(Begin, End, Pred) {}
        -:  479:
        -:  480:  filter_iterator_impl &operator--() {
        -:  481:    BaseT::operator--();
        -:  482:    findPrevValid();
        -:  483:    return *this;
        -:  484:  }
        -:  485:};
        -:  486:
        -:  487:namespace detail {
        -:  488:
        -:  489:template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {
        -:  490:  using type = std::forward_iterator_tag;
        -:  491:};
        -:  492:
        -:  493:template <> struct fwd_or_bidi_tag_impl<true> {
        -:  494:  using type = std::bidirectional_iterator_tag;
        -:  495:};
        -:  496:
        -:  497:/// Helper which sets its type member to forward_iterator_tag if the category
        -:  498:/// of \p IterT does not derive from bidirectional_iterator_tag, and to
        -:  499:/// bidirectional_iterator_tag otherwise.
        -:  500:template <typename IterT> struct fwd_or_bidi_tag {
        -:  501:  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<
        -:  502:      std::bidirectional_iterator_tag,
        -:  503:      typename std::iterator_traits<IterT>::iterator_category>::value>::type;
        -:  504:};
        -:  505:
        -:  506:} // namespace detail
        -:  507:
        -:  508:/// Defines filter_iterator to a suitable specialization of
        -:  509:/// filter_iterator_impl, based on the underlying iterator's category.
        -:  510:template <typename WrappedIteratorT, typename PredicateT>
        -:  511:using filter_iterator = filter_iterator_impl<
        -:  512:    WrappedIteratorT, PredicateT,
        -:  513:    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;
        -:  514:
        -:  515:/// Convenience function that takes a range of elements and a predicate,
        -:  516:/// and return a new filter_iterator range.
        -:  517:///
        -:  518:/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the
        -:  519:/// lifetime of that temporary is not kept by the returned range object, and the
        -:  520:/// temporary is going to be dropped on the floor after the make_iterator_range
        -:  521:/// full expression that contains this function call.
        -:  522:template <typename RangeT, typename PredicateT>
        -:  523:iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>
        -:  524:make_filter_range(RangeT &&Range, PredicateT Pred) {
        -:  525:  using FilterIteratorT =
        -:  526:      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;
        -:  527:  return make_range(
        -:  528:      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),
        -:  529:                      std::end(std::forward<RangeT>(Range)), Pred),
        -:  530:      FilterIteratorT(std::end(std::forward<RangeT>(Range)),
        -:  531:                      std::end(std::forward<RangeT>(Range)), Pred));
        -:  532:}
        -:  533:
        -:  534:/// A pseudo-iterator adaptor that is designed to implement "early increment"
        -:  535:/// style loops.
        -:  536:///
        -:  537:/// This is *not a normal iterator* and should almost never be used directly. It
        -:  538:/// is intended primarily to be used with range based for loops and some range
        -:  539:/// algorithms.
        -:  540:///
        -:  541:/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but
        -:  542:/// somewhere between them. The constraints of these iterators are:
        -:  543:///
        -:  544:/// - On construction or after being incremented, it is comparable and
        -:  545:///   dereferencable. It is *not* incrementable.
        -:  546:/// - After being dereferenced, it is neither comparable nor dereferencable, it
        -:  547:///   is only incrementable.
        -:  548:///
        -:  549:/// This means you can only dereference the iterator once, and you can only
        -:  550:/// increment it once between dereferences.
        -:  551:template <typename WrappedIteratorT>
        -:  552:class early_inc_iterator_impl
        -:  553:    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,
        -:  554:                                   WrappedIteratorT, std::input_iterator_tag> {
        -:  555:  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;
        -:  556:
        -:  557:  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;
        -:  558:
        -:  559:protected:
        -:  560:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  561:  bool IsEarlyIncremented = false;
        -:  562:#endif
        -:  563:
        -:  564:public:
        -:  565:  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}
        -:  566:
        -:  567:  using BaseT::operator*;
        -:  568:  decltype(*std::declval<WrappedIteratorT>()) operator*() {
        -:  569:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  570:    assert(!IsEarlyIncremented && "Cannot dereference twice!");
        -:  571:    IsEarlyIncremented = true;
        -:  572:#endif
        -:  573:    return *(this->I)++;
        -:  574:  }
        -:  575:
        -:  576:  using BaseT::operator++;
        -:  577:  early_inc_iterator_impl &operator++() {
        -:  578:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  579:    assert(IsEarlyIncremented && "Cannot increment before dereferencing!");
        -:  580:    IsEarlyIncremented = false;
        -:  581:#endif
        -:  582:    return *this;
        -:  583:  }
        -:  584:
        -:  585:  friend bool operator==(const early_inc_iterator_impl &LHS,
        -:  586:                         const early_inc_iterator_impl &RHS) {
        -:  587:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  588:    assert(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!");
        -:  589:#endif
        -:  590:    return (const BaseT &)LHS == (const BaseT &)RHS;
        -:  591:  }
        -:  592:};
        -:  593:
        -:  594:/// Make a range that does early increment to allow mutation of the underlying
        -:  595:/// range without disrupting iteration.
        -:  596:///
        -:  597:/// The underlying iterator will be incremented immediately after it is
        -:  598:/// dereferenced, allowing deletion of the current node or insertion of nodes to
        -:  599:/// not disrupt iteration provided they do not invalidate the *next* iterator --
        -:  600:/// the current iterator can be invalidated.
        -:  601:///
        -:  602:/// This requires a very exact pattern of use that is only really suitable to
        -:  603:/// range based for loops and other range algorithms that explicitly guarantee
        -:  604:/// to dereference exactly once each element, and to increment exactly once each
        -:  605:/// element.
        -:  606:template <typename RangeT>
        -:  607:iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>
        -:  608:make_early_inc_range(RangeT &&Range) {
        -:  609:  using EarlyIncIteratorT =
        -:  610:      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;
        -:  611:  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),
        -:  612:                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));
        -:  613:}
        -:  614:
        -:  615:// forward declarations required by zip_shortest/zip_first/zip_longest
        -:  616:template <typename R, typename UnaryPredicate>
        -:  617:bool all_of(R &&range, UnaryPredicate P);
        -:  618:template <typename R, typename UnaryPredicate>
        -:  619:bool any_of(R &&range, UnaryPredicate P);
        -:  620:
        -:  621:namespace detail {
        -:  622:
        -:  623:using std::declval;
        -:  624:
        -:  625:// We have to alias this since inlining the actual type at the usage site
        -:  626:// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.
        -:  627:template<typename... Iters> struct ZipTupleType {
        -:  628:  using type = std::tuple<decltype(*declval<Iters>())...>;
        -:  629:};
        -:  630:
        -:  631:template <typename ZipType, typename... Iters>
        -:  632:using zip_traits = iterator_facade_base<
        -:  633:    ZipType, typename std::common_type<std::bidirectional_iterator_tag,
        -:  634:                                       typename std::iterator_traits<
        -:  635:                                           Iters>::iterator_category...>::type,
        -:  636:    // ^ TODO: Implement random access methods.
        -:  637:    typename ZipTupleType<Iters...>::type,
        -:  638:    typename std::iterator_traits<typename std::tuple_element<
        -:  639:        0, std::tuple<Iters...>>::type>::difference_type,
        -:  640:    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all
        -:  641:    // inner iterators have the same difference_type. It would fail if, for
        -:  642:    // instance, the second field's difference_type were non-numeric while the
        -:  643:    // first is.
        -:  644:    typename ZipTupleType<Iters...>::type *,
        -:  645:    typename ZipTupleType<Iters...>::type>;
        -:  646:
        -:  647:template <typename ZipType, typename... Iters>
        -:  648:struct zip_common : public zip_traits<ZipType, Iters...> {
        -:  649:  using Base = zip_traits<ZipType, Iters...>;
        -:  650:  using value_type = typename Base::value_type;
        -:  651:
        -:  652:  std::tuple<Iters...> iterators;
        -:  653:
        -:  654:protected:
        -:  655:  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
        -:  656:    return value_type(*std::get<Ns>(iterators)...);
        -:  657:  }
        -:  658:
        -:  659:  template <size_t... Ns>
        -:  660:  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {
        -:  661:    return std::tuple<Iters...>(std::next(std::get<Ns>(iterators))...);
        -:  662:  }
        -:  663:
        -:  664:  template <size_t... Ns>
        -:  665:  decltype(iterators) tup_dec(std::index_sequence<Ns...>) const {
        -:  666:    return std::tuple<Iters...>(std::prev(std::get<Ns>(iterators))...);
        -:  667:  }
        -:  668:
        -:  669:  template <size_t... Ns>
        -:  670:  bool test_all_equals(const zip_common &other,
        -:  671:            std::index_sequence<Ns...>) const {
        -:  672:    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) ==
        -:  673:                                              std::get<Ns>(other.iterators)...},
        -:  674:                  identity<bool>{});
        -:  675:  }
        -:  676:
        -:  677:public:
        -:  678:  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}
        -:  679:
        -:  680:  value_type operator*() const {
        -:  681:    return deref(std::index_sequence_for<Iters...>{});
        -:  682:  }
        -:  683:
        -:  684:  ZipType &operator++() {
        -:  685:    iterators = tup_inc(std::index_sequence_for<Iters...>{});
        -:  686:    return *reinterpret_cast<ZipType *>(this);
        -:  687:  }
        -:  688:
        -:  689:  ZipType &operator--() {
        -:  690:    static_assert(Base::IsBidirectional,
        -:  691:                  "All inner iterators must be at least bidirectional.");
        -:  692:    iterators = tup_dec(std::index_sequence_for<Iters...>{});
        -:  693:    return *reinterpret_cast<ZipType *>(this);
        -:  694:  }
        -:  695:
        -:  696:  /// Return true if all the iterator are matching `other`'s iterators.
        -:  697:  bool all_equals(zip_common &other) {
        -:  698:    return test_all_equals(other, std::index_sequence_for<Iters...>{});
        -:  699:  }
        -:  700:};
        -:  701:
        -:  702:template <typename... Iters>
        -:  703:struct zip_first : public zip_common<zip_first<Iters...>, Iters...> {
        -:  704:  using Base = zip_common<zip_first<Iters...>, Iters...>;
        -:  705:
        -:  706:  bool operator==(const zip_first<Iters...> &other) const {
        -:  707:    return std::get<0>(this->iterators) == std::get<0>(other.iterators);
        -:  708:  }
        -:  709:
        -:  710:  zip_first(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}
        -:  711:};
        -:  712:
        -:  713:template <typename... Iters>
        -:  714:class zip_shortest : public zip_common<zip_shortest<Iters...>, Iters...> {
        -:  715:  template <size_t... Ns>
        -:  716:  bool test(const zip_shortest<Iters...> &other,
        -:  717:            std::index_sequence<Ns...>) const {
        -:  718:    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) !=
        -:  719:                                              std::get<Ns>(other.iterators)...},
        -:  720:                  identity<bool>{});
        -:  721:  }
        -:  722:
        -:  723:public:
        -:  724:  using Base = zip_common<zip_shortest<Iters...>, Iters...>;
        -:  725:
        -:  726:  zip_shortest(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}
        -:  727:
        -:  728:  bool operator==(const zip_shortest<Iters...> &other) const {
        -:  729:    return !test(other, std::index_sequence_for<Iters...>{});
        -:  730:  }
        -:  731:};
        -:  732:
        -:  733:template <template <typename...> class ItType, typename... Args> class zippy {
        -:  734:public:
        -:  735:  using iterator = ItType<decltype(std::begin(std::declval<Args>()))...>;
        -:  736:  using iterator_category = typename iterator::iterator_category;
        -:  737:  using value_type = typename iterator::value_type;
        -:  738:  using difference_type = typename iterator::difference_type;
        -:  739:  using pointer = typename iterator::pointer;
        -:  740:  using reference = typename iterator::reference;
        -:  741:
        -:  742:private:
        -:  743:  std::tuple<Args...> ts;
        -:  744:
        -:  745:  template <size_t... Ns>
        -:  746:  iterator begin_impl(std::index_sequence<Ns...>) const {
        -:  747:    return iterator(std::begin(std::get<Ns>(ts))...);
        -:  748:  }
        -:  749:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
        -:  750:    return iterator(std::end(std::get<Ns>(ts))...);
        -:  751:  }
        -:  752:
        -:  753:public:
        -:  754:  zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}
        -:  755:
        -:  756:  iterator begin() const {
        -:  757:    return begin_impl(std::index_sequence_for<Args...>{});
        -:  758:  }
        -:  759:  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }
        -:  760:};
        -:  761:
        -:  762:} // end namespace detail
        -:  763:
        -:  764:/// zip iterator for two or more iteratable types.
        -:  765:template <typename T, typename U, typename... Args>
        -:  766:detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,
        -:  767:                                                       Args &&... args) {
        -:  768:  return detail::zippy<detail::zip_shortest, T, U, Args...>(
        -:  769:      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
        -:  770:}
        -:  771:
        -:  772:/// zip iterator that, for the sake of efficiency, assumes the first iteratee to
        -:  773:/// be the shortest.
        -:  774:template <typename T, typename U, typename... Args>
        -:  775:detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,
        -:  776:                                                          Args &&... args) {
        -:  777:  return detail::zippy<detail::zip_first, T, U, Args...>(
        -:  778:      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
        -:  779:}
        -:  780:
        -:  781:namespace detail {
        -:  782:template <typename Iter>
        -:  783:Iter next_or_end(const Iter &I, const Iter &End) {
        -:  784:  if (I == End)
        -:  785:    return End;
        -:  786:  return std::next(I);
        -:  787:}
        -:  788:
        -:  789:template <typename Iter>
        -:  790:auto deref_or_none(const Iter &I, const Iter &End) -> llvm::Optional<
        -:  791:    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {
        -:  792:  if (I == End)
        -:  793:    return None;
        -:  794:  return *I;
        -:  795:}
        -:  796:
        -:  797:template <typename Iter> struct ZipLongestItemType {
        -:  798:  using type =
        -:  799:      llvm::Optional<typename std::remove_const<typename std::remove_reference<
        -:  800:          decltype(*std::declval<Iter>())>::type>::type>;
        -:  801:};
        -:  802:
        -:  803:template <typename... Iters> struct ZipLongestTupleType {
        -:  804:  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;
        -:  805:};
        -:  806:
        -:  807:template <typename... Iters>
        -:  808:class zip_longest_iterator
        -:  809:    : public iterator_facade_base<
        -:  810:          zip_longest_iterator<Iters...>,
        -:  811:          typename std::common_type<
        -:  812:              std::forward_iterator_tag,
        -:  813:              typename std::iterator_traits<Iters>::iterator_category...>::type,
        -:  814:          typename ZipLongestTupleType<Iters...>::type,
        -:  815:          typename std::iterator_traits<typename std::tuple_element<
        -:  816:              0, std::tuple<Iters...>>::type>::difference_type,
        -:  817:          typename ZipLongestTupleType<Iters...>::type *,
        -:  818:          typename ZipLongestTupleType<Iters...>::type> {
        -:  819:public:
        -:  820:  using value_type = typename ZipLongestTupleType<Iters...>::type;
        -:  821:
        -:  822:private:
        -:  823:  std::tuple<Iters...> iterators;
        -:  824:  std::tuple<Iters...> end_iterators;
        -:  825:
        -:  826:  template <size_t... Ns>
        -:  827:  bool test(const zip_longest_iterator<Iters...> &other,
        -:  828:            std::index_sequence<Ns...>) const {
        -:  829:    return llvm::any_of(
        -:  830:        std::initializer_list<bool>{std::get<Ns>(this->iterators) !=
        -:  831:                                    std::get<Ns>(other.iterators)...},
        -:  832:        identity<bool>{});
        -:  833:  }
        -:  834:
        -:  835:  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
        -:  836:    return value_type(
        -:  837:        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
        -:  838:  }
        -:  839:
        -:  840:  template <size_t... Ns>
        -:  841:  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {
        -:  842:    return std::tuple<Iters...>(
        -:  843:        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
        -:  844:  }
        -:  845:
        -:  846:public:
        -:  847:  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)
        -:  848:      : iterators(std::forward<Iters>(ts.first)...),
        -:  849:        end_iterators(std::forward<Iters>(ts.second)...) {}
        -:  850:
        -:  851:  value_type operator*() const {
        -:  852:    return deref(std::index_sequence_for<Iters...>{});
        -:  853:  }
        -:  854:
        -:  855:  zip_longest_iterator<Iters...> &operator++() {
        -:  856:    iterators = tup_inc(std::index_sequence_for<Iters...>{});
        -:  857:    return *this;
        -:  858:  }
        -:  859:
        -:  860:  bool operator==(const zip_longest_iterator<Iters...> &other) const {
        -:  861:    return !test(other, std::index_sequence_for<Iters...>{});
        -:  862:  }
        -:  863:};
        -:  864:
        -:  865:template <typename... Args> class zip_longest_range {
        -:  866:public:
        -:  867:  using iterator =
        -:  868:      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;
        -:  869:  using iterator_category = typename iterator::iterator_category;
        -:  870:  using value_type = typename iterator::value_type;
        -:  871:  using difference_type = typename iterator::difference_type;
        -:  872:  using pointer = typename iterator::pointer;
        -:  873:  using reference = typename iterator::reference;
        -:  874:
        -:  875:private:
        -:  876:  std::tuple<Args...> ts;
        -:  877:
        -:  878:  template <size_t... Ns>
        -:  879:  iterator begin_impl(std::index_sequence<Ns...>) const {
        -:  880:    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),
        -:  881:                                   adl_end(std::get<Ns>(ts)))...);
        -:  882:  }
        -:  883:
        -:  884:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
        -:  885:    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),
        -:  886:                                   adl_end(std::get<Ns>(ts)))...);
        -:  887:  }
        -:  888:
        -:  889:public:
        -:  890:  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}
        -:  891:
        -:  892:  iterator begin() const {
        -:  893:    return begin_impl(std::index_sequence_for<Args...>{});
        -:  894:  }
        -:  895:  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }
        -:  896:};
        -:  897:} // namespace detail
        -:  898:
        -:  899:/// Iterate over two or more iterators at the same time. Iteration continues
        -:  900:/// until all iterators reach the end. The llvm::Optional only contains a value
        -:  901:/// if the iterator has not reached the end.
        -:  902:template <typename T, typename U, typename... Args>
        -:  903:detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,
        -:  904:                                                     Args &&... args) {
        -:  905:  return detail::zip_longest_range<T, U, Args...>(
        -:  906:      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
        -:  907:}
        -:  908:
        -:  909:/// Iterator wrapper that concatenates sequences together.
        -:  910:///
        -:  911:/// This can concatenate different iterators, even with different types, into
        -:  912:/// a single iterator provided the value types of all the concatenated
        -:  913:/// iterators expose `reference` and `pointer` types that can be converted to
        -:  914:/// `ValueT &` and `ValueT *` respectively. It doesn't support more
        -:  915:/// interesting/customized pointer or reference types.
        -:  916:///
        -:  917:/// Currently this only supports forward or higher iterator categories as
        -:  918:/// inputs and always exposes a forward iterator interface.
        -:  919:template <typename ValueT, typename... IterTs>
        -:  920:class concat_iterator
        -:  921:    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,
        -:  922:                                  std::forward_iterator_tag, ValueT> {
        -:  923:  using BaseT = typename concat_iterator::iterator_facade_base;
        -:  924:
        -:  925:  /// We store both the current and end iterators for each concatenated
        -:  926:  /// sequence in a tuple of pairs.
        -:  927:  ///
        -:  928:  /// Note that something like iterator_range seems nice at first here, but the
        -:  929:  /// range properties are of little benefit and end up getting in the way
        -:  930:  /// because we need to do mutation on the current iterators.
        -:  931:  std::tuple<IterTs...> Begins;
        -:  932:  std::tuple<IterTs...> Ends;
        -:  933:
        -:  934:  /// Attempts to increment a specific iterator.
        -:  935:  ///
        -:  936:  /// Returns true if it was able to increment the iterator. Returns false if
        -:  937:  /// the iterator is already at the end iterator.
        -:  938:  template <size_t Index> bool incrementHelper() {
        -:  939:    auto &Begin = std::get<Index>(Begins);
        -:  940:    auto &End = std::get<Index>(Ends);
        -:  941:    if (Begin == End)
        -:  942:      return false;
        -:  943:
        -:  944:    ++Begin;
        -:  945:    return true;
        -:  946:  }
        -:  947:
        -:  948:  /// Increments the first non-end iterator.
        -:  949:  ///
        -:  950:  /// It is an error to call this with all iterators at the end.
        -:  951:  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {
        -:  952:    // Build a sequence of functions to increment each iterator if possible.
        -:  953:    bool (concat_iterator::*IncrementHelperFns[])() = {
        -:  954:        &concat_iterator::incrementHelper<Ns>...};
        -:  955:
        -:  956:    // Loop over them, and stop as soon as we succeed at incrementing one.
        -:  957:    for (auto &IncrementHelperFn : IncrementHelperFns)
        -:  958:      if ((this->*IncrementHelperFn)())
        -:  959:        return;
        -:  960:
        -:  961:    llvm_unreachable("Attempted to increment an end concat iterator!");
        -:  962:  }
        -:  963:
        -:  964:  /// Returns null if the specified iterator is at the end. Otherwise,
        -:  965:  /// dereferences the iterator and returns the address of the resulting
        -:  966:  /// reference.
        -:  967:  template <size_t Index> ValueT *getHelper() const {
        -:  968:    auto &Begin = std::get<Index>(Begins);
        -:  969:    auto &End = std::get<Index>(Ends);
        -:  970:    if (Begin == End)
        -:  971:      return nullptr;
        -:  972:
        -:  973:    return &*Begin;
        -:  974:  }
        -:  975:
        -:  976:  /// Finds the first non-end iterator, dereferences, and returns the resulting
        -:  977:  /// reference.
        -:  978:  ///
        -:  979:  /// It is an error to call this with all iterators at the end.
        -:  980:  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {
        -:  981:    // Build a sequence of functions to get from iterator if possible.
        -:  982:    ValueT *(concat_iterator::*GetHelperFns[])() const = {
        -:  983:        &concat_iterator::getHelper<Ns>...};
        -:  984:
        -:  985:    // Loop over them, and return the first result we find.
        -:  986:    for (auto &GetHelperFn : GetHelperFns)
        -:  987:      if (ValueT *P = (this->*GetHelperFn)())
        -:  988:        return *P;
        -:  989:
        -:  990:    llvm_unreachable("Attempted to get a pointer from an end concat iterator!");
        -:  991:  }
        -:  992:
        -:  993:public:
        -:  994:  /// Constructs an iterator from a sequence of ranges.
        -:  995:  ///
        -:  996:  /// We need the full range to know how to switch between each of the
        -:  997:  /// iterators.
        -:  998:  template <typename... RangeTs>
        -:  999:  explicit concat_iterator(RangeTs &&... Ranges)
        -: 1000:      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}
        -: 1001:
        -: 1002:  using BaseT::operator++;
        -: 1003:
        -: 1004:  concat_iterator &operator++() {
        -: 1005:    increment(std::index_sequence_for<IterTs...>());
        -: 1006:    return *this;
        -: 1007:  }
        -: 1008:
        -: 1009:  ValueT &operator*() const {
        -: 1010:    return get(std::index_sequence_for<IterTs...>());
        -: 1011:  }
        -: 1012:
        -: 1013:  bool operator==(const concat_iterator &RHS) const {
        -: 1014:    return Begins == RHS.Begins && Ends == RHS.Ends;
        -: 1015:  }
        -: 1016:};
        -: 1017:
        -: 1018:namespace detail {
        -: 1019:
        -: 1020:/// Helper to store a sequence of ranges being concatenated and access them.
        -: 1021:///
        -: 1022:/// This is designed to facilitate providing actual storage when temporaries
        -: 1023:/// are passed into the constructor such that we can use it as part of range
        -: 1024:/// based for loops.
        -: 1025:template <typename ValueT, typename... RangeTs> class concat_range {
        -: 1026:public:
        -: 1027:  using iterator =
        -: 1028:      concat_iterator<ValueT,
        -: 1029:                      decltype(std::begin(std::declval<RangeTs &>()))...>;
        -: 1030:
        -: 1031:private:
        -: 1032:  std::tuple<RangeTs...> Ranges;
        -: 1033:
        -: 1034:  template <size_t... Ns>
        -: 1035:  iterator begin_impl(std::index_sequence<Ns...>) {
        -: 1036:    return iterator(std::get<Ns>(Ranges)...);
        -: 1037:  }
        -: 1038:  template <size_t... Ns>
        -: 1039:  iterator begin_impl(std::index_sequence<Ns...>) const {
        -: 1040:    return iterator(std::get<Ns>(Ranges)...);
        -: 1041:  }
        -: 1042:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {
        -: 1043:    return iterator(make_range(std::end(std::get<Ns>(Ranges)),
        -: 1044:                               std::end(std::get<Ns>(Ranges)))...);
        -: 1045:  }
        -: 1046:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
        -: 1047:    return iterator(make_range(std::end(std::get<Ns>(Ranges)),
        -: 1048:                               std::end(std::get<Ns>(Ranges)))...);
        -: 1049:  }
        -: 1050:
        -: 1051:public:
        -: 1052:  concat_range(RangeTs &&... Ranges)
        -: 1053:      : Ranges(std::forward<RangeTs>(Ranges)...) {}
        -: 1054:
        -: 1055:  iterator begin() {
        -: 1056:    return begin_impl(std::index_sequence_for<RangeTs...>{});
        -: 1057:  }
        -: 1058:  iterator begin() const {
        -: 1059:    return begin_impl(std::index_sequence_for<RangeTs...>{});
        -: 1060:  }
        -: 1061:  iterator end() {
        -: 1062:    return end_impl(std::index_sequence_for<RangeTs...>{});
        -: 1063:  }
        -: 1064:  iterator end() const {
        -: 1065:    return end_impl(std::index_sequence_for<RangeTs...>{});
        -: 1066:  }
        -: 1067:};
        -: 1068:
        -: 1069:} // end namespace detail
        -: 1070:
        -: 1071:/// Concatenated range across two or more ranges.
        -: 1072:///
        -: 1073:/// The desired value type must be explicitly specified.
        -: 1074:template <typename ValueT, typename... RangeTs>
        -: 1075:detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {
        -: 1076:  static_assert(sizeof...(RangeTs) > 1,
        -: 1077:                "Need more than one range to concatenate!");
        -: 1078:  return detail::concat_range<ValueT, RangeTs...>(
        -: 1079:      std::forward<RangeTs>(Ranges)...);
        -: 1080:}
        -: 1081:
        -: 1082:/// A utility class used to implement an iterator that contains some base object
        -: 1083:/// and an index. The iterator moves the index but keeps the base constant.
        -: 1084:template <typename DerivedT, typename BaseT, typename T,
        -: 1085:          typename PointerT = T *, typename ReferenceT = T &>
        -: 1086:class indexed_accessor_iterator
        -: 1087:    : public llvm::iterator_facade_base<DerivedT,
        -: 1088:                                        std::random_access_iterator_tag, T,
        -: 1089:                                        std::ptrdiff_t, PointerT, ReferenceT> {
        -: 1090:public:
        -: 1091:  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {
        -: 1092:    assert(base == rhs.base && "incompatible iterators");
        -: 1093:    return index - rhs.index;
        -: 1094:  }
        -: 1095:  bool operator==(const indexed_accessor_iterator &rhs) const {
        -: 1096:    return base == rhs.base && index == rhs.index;
        -: 1097:  }
        -: 1098:  bool operator<(const indexed_accessor_iterator &rhs) const {
        -: 1099:    assert(base == rhs.base && "incompatible iterators");
        -: 1100:    return index < rhs.index;
        -: 1101:  }
        -: 1102:
        -: 1103:  DerivedT &operator+=(ptrdiff_t offset) {
        -: 1104:    this->index += offset;
        -: 1105:    return static_cast<DerivedT &>(*this);
        -: 1106:  }
        -: 1107:  DerivedT &operator-=(ptrdiff_t offset) {
        -: 1108:    this->index -= offset;
        -: 1109:    return static_cast<DerivedT &>(*this);
        -: 1110:  }
        -: 1111:
        -: 1112:  /// Returns the current index of the iterator.
        -: 1113:  ptrdiff_t getIndex() const { return index; }
        -: 1114:
        -: 1115:  /// Returns the current base of the iterator.
        -: 1116:  const BaseT &getBase() const { return base; }
        -: 1117:
        -: 1118:protected:
        -: 1119:  indexed_accessor_iterator(BaseT base, ptrdiff_t index)
        -: 1120:      : base(base), index(index) {}
        -: 1121:  BaseT base;
        -: 1122:  ptrdiff_t index;
        -: 1123:};
        -: 1124:
        -: 1125:namespace detail {
        -: 1126:/// The class represents the base of a range of indexed_accessor_iterators. It
        -: 1127:/// provides support for many different range functionalities, e.g.
        -: 1128:/// drop_front/slice/etc.. Derived range classes must implement the following
        -: 1129:/// static methods:
        -: 1130:///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)
        -: 1131:///     - Dereference an iterator pointing to the base object at the given
        -: 1132:///       index.
        -: 1133:///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)
        -: 1134:///     - Return a new base that is offset from the provide base by 'index'
        -: 1135:///       elements.
        -: 1136:template <typename DerivedT, typename BaseT, typename T,
        -: 1137:          typename PointerT = T *, typename ReferenceT = T &>
        -: 1138:class indexed_accessor_range_base {
        -: 1139:public:
        -: 1140:  using RangeBaseT = indexed_accessor_range_base;
        -: 1141:
        -: 1142:  /// An iterator element of this range.
        -: 1143:  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,
        -: 1144:                                                    PointerT, ReferenceT> {
        -: 1145:  public:
        -: 1146:    // Index into this iterator, invoking a static method on the derived type.
        -: 1147:    ReferenceT operator*() const {
        -: 1148:      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());
        -: 1149:    }
        -: 1150:
        -: 1151:  private:
        -: 1152:    iterator(BaseT owner, ptrdiff_t curIndex)
        -: 1153:        : iterator::indexed_accessor_iterator(owner, curIndex) {}
        -: 1154:
        -: 1155:    /// Allow access to the constructor.
        -: 1156:    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,
        -: 1157:                                       ReferenceT>;
        -: 1158:  };
        -: 1159:
        -: 1160:  indexed_accessor_range_base(iterator begin, iterator end)
        -: 1161:      : base(offset_base(begin.getBase(), begin.getIndex())),
        -: 1162:        count(end.getIndex() - begin.getIndex()) {}
        -: 1163:  indexed_accessor_range_base(const iterator_range<iterator> &range)
        -: 1164:      : indexed_accessor_range_base(range.begin(), range.end()) {}
        -: 1165:  indexed_accessor_range_base(BaseT base, ptrdiff_t count)
        -: 1166:      : base(base), count(count) {}
        -: 1167:
        -: 1168:  iterator begin() const { return iterator(base, 0); }
        -: 1169:  iterator end() const { return iterator(base, count); }
        -: 1170:  ReferenceT operator[](size_t Index) const {
        -: 1171:    assert(Index < size() && "invalid index for value range");
        -: 1172:    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));
        -: 1173:  }
        -: 1174:  ReferenceT front() const {
        -: 1175:    assert(!empty() && "expected non-empty range");
        -: 1176:    return (*this)[0];
        -: 1177:  }
        -: 1178:  ReferenceT back() const {
        -: 1179:    assert(!empty() && "expected non-empty range");
        -: 1180:    return (*this)[size() - 1];
        -: 1181:  }
        -: 1182:
        -: 1183:  /// Compare this range with another.
        -: 1184:  template <typename OtherT>
        -: 1185:  friend bool operator==(const indexed_accessor_range_base &lhs,
        -: 1186:                         const OtherT &rhs) {
        -: 1187:    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
        -: 1188:  }
        -: 1189:  template <typename OtherT>
        -: 1190:  friend bool operator!=(const indexed_accessor_range_base &lhs,
        -: 1191:                         const OtherT &rhs) {
        -: 1192:    return !(lhs == rhs);
        -: 1193:  }
        -: 1194:
        -: 1195:  /// Return the size of this range.
        -: 1196:  size_t size() const { return count; }
        -: 1197:
        -: 1198:  /// Return if the range is empty.
        -: 1199:  bool empty() const { return size() == 0; }
        -: 1200:
        -: 1201:  /// Drop the first N elements, and keep M elements.
        -: 1202:  DerivedT slice(size_t n, size_t m) const {
        -: 1203:    assert(n + m <= size() && "invalid size specifiers");
        -: 1204:    return DerivedT(offset_base(base, n), m);
        -: 1205:  }
        -: 1206:
        -: 1207:  /// Drop the first n elements.
        -: 1208:  DerivedT drop_front(size_t n = 1) const {
        -: 1209:    assert(size() >= n && "Dropping more elements than exist");
        -: 1210:    return slice(n, size() - n);
        -: 1211:  }
        -: 1212:  /// Drop the last n elements.
        -: 1213:  DerivedT drop_back(size_t n = 1) const {
        -: 1214:    assert(size() >= n && "Dropping more elements than exist");
        -: 1215:    return DerivedT(base, size() - n);
        -: 1216:  }
        -: 1217:
        -: 1218:  /// Take the first n elements.
        -: 1219:  DerivedT take_front(size_t n = 1) const {
        -: 1220:    return n < size() ? drop_back(size() - n)
        -: 1221:                      : static_cast<const DerivedT &>(*this);
        -: 1222:  }
        -: 1223:
        -: 1224:  /// Take the last n elements.
        -: 1225:  DerivedT take_back(size_t n = 1) const {
        -: 1226:    return n < size() ? drop_front(size() - n)
        -: 1227:                      : static_cast<const DerivedT &>(*this);
        -: 1228:  }
        -: 1229:
        -: 1230:  /// Allow conversion to any type accepting an iterator_range.
        -: 1231:  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<
        -: 1232:                                 RangeT, iterator_range<iterator>>::value>>
        -: 1233:  operator RangeT() const {
        -: 1234:    return RangeT(iterator_range<iterator>(*this));
        -: 1235:  }
        -: 1236:
        -: 1237:  /// Returns the base of this range.
        -: 1238:  const BaseT &getBase() const { return base; }
        -: 1239:
        -: 1240:private:
        -: 1241:  /// Offset the given base by the given amount.
        -: 1242:  static BaseT offset_base(const BaseT &base, size_t n) {
        -: 1243:    return n == 0 ? base : DerivedT::offset_base(base, n);
        -: 1244:  }
        -: 1245:
        -: 1246:protected:
        -: 1247:  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;
        -: 1248:  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;
        -: 1249:  indexed_accessor_range_base &
        -: 1250:  operator=(const indexed_accessor_range_base &) = default;
        -: 1251:
        -: 1252:  /// The base that owns the provided range of values.
        -: 1253:  BaseT base;
        -: 1254:  /// The size from the owning range.
        -: 1255:  ptrdiff_t count;
        -: 1256:};
        -: 1257:} // end namespace detail
        -: 1258:
        -: 1259:/// This class provides an implementation of a range of
        -: 1260:/// indexed_accessor_iterators where the base is not indexable. Ranges with
        -: 1261:/// bases that are offsetable should derive from indexed_accessor_range_base
        -: 1262:/// instead. Derived range classes are expected to implement the following
        -: 1263:/// static method:
        -: 1264:///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)
        -: 1265:///     - Dereference an iterator pointing to a parent base at the given index.
        -: 1266:template <typename DerivedT, typename BaseT, typename T,
        -: 1267:          typename PointerT = T *, typename ReferenceT = T &>
        -: 1268:class indexed_accessor_range
        -: 1269:    : public detail::indexed_accessor_range_base<
        -: 1270:          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {
        -: 1271:public:
        -: 1272:  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)
        -: 1273:      : detail::indexed_accessor_range_base<
        -: 1274:            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(
        -: 1275:            std::make_pair(base, startIndex), count) {}
        -: 1276:  using detail::indexed_accessor_range_base<
        -: 1277:      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,
        -: 1278:      ReferenceT>::indexed_accessor_range_base;
        -: 1279:
        -: 1280:  /// Returns the current base of the range.
        -: 1281:  const BaseT &getBase() const { return this->base.first; }
        -: 1282:
        -: 1283:  /// Returns the current start index of the range.
        -: 1284:  ptrdiff_t getStartIndex() const { return this->base.second; }
        -: 1285:
        -: 1286:  /// See `detail::indexed_accessor_range_base` for details.
        -: 1287:  static std::pair<BaseT, ptrdiff_t>
        -: 1288:  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {
        -: 1289:    // We encode the internal base as a pair of the derived base and a start
        -: 1290:    // index into the derived base.
        -: 1291:    return std::make_pair(base.first, base.second + index);
        -: 1292:  }
        -: 1293:  /// See `detail::indexed_accessor_range_base` for details.
        -: 1294:  static ReferenceT
        -: 1295:  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,
        -: 1296:                       ptrdiff_t index) {
        -: 1297:    return DerivedT::dereference(base.first, base.second + index);
        -: 1298:  }
        -: 1299:};
        -: 1300:
        -: 1301:namespace detail {
        -: 1302:/// Return a reference to the first or second member of a reference. Otherwise,
        -: 1303:/// return a copy of the member of a temporary.
        -: 1304:///
        -: 1305:/// When passing a range whose iterators return values instead of references,
        -: 1306:/// the reference must be dropped from `decltype((elt.first))`, which will
        -: 1307:/// always be a reference, to avoid returning a reference to a temporary.
        -: 1308:template <typename EltTy, typename FirstTy> class first_or_second_type {
        -: 1309:public:
        -: 1310:  using type =
        -: 1311:      typename std::conditional_t<std::is_reference<EltTy>::value, FirstTy,
        -: 1312:                                  std::remove_reference_t<FirstTy>>;
        -: 1313:};
        -: 1314:} // end namespace detail
        -: 1315:
        -: 1316:/// Given a container of pairs, return a range over the first elements.
        -: 1317:template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {
        -: 1318:  using EltTy = decltype((*std::begin(c)));
        -: 1319:  return llvm::map_range(std::forward<ContainerTy>(c),
        -: 1320:                         [](EltTy elt) -> typename detail::first_or_second_type<
        -: 1321:                                           EltTy, decltype((elt.first))>::type {
        -: 1322:                           return elt.first;
        -: 1323:                         });
        -: 1324:}
        -: 1325:
        -: 1326:/// Given a container of pairs, return a range over the second elements.
        -: 1327:template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {
        -: 1328:  using EltTy = decltype((*std::begin(c)));
        -: 1329:  return llvm::map_range(
        -: 1330:      std::forward<ContainerTy>(c),
        -: 1331:      [](EltTy elt) ->
        -: 1332:      typename detail::first_or_second_type<EltTy,
        -: 1333:                                            decltype((elt.second))>::type {
        -: 1334:        return elt.second;
        -: 1335:      });
        -: 1336:}
        -: 1337:
        -: 1338://===----------------------------------------------------------------------===//
        -: 1339://     Extra additions to <utility>
        -: 1340://===----------------------------------------------------------------------===//
        -: 1341:
        -: 1342:/// Function object to check whether the first component of a std::pair
        -: 1343:/// compares less than the first component of another std::pair.
        -: 1344:struct less_first {
        -: 1345:  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
        -: 1346:    return std::less<>()(lhs.first, rhs.first);
        -: 1347:  }
        -: 1348:};
        -: 1349:
        -: 1350:/// Function object to check whether the second component of a std::pair
        -: 1351:/// compares less than the second component of another std::pair.
        -: 1352:struct less_second {
        -: 1353:  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
        -: 1354:    return std::less<>()(lhs.second, rhs.second);
        -: 1355:  }
        -: 1356:};
        -: 1357:
        -: 1358:/// \brief Function object to apply a binary function to the first component of
        -: 1359:/// a std::pair.
        -: 1360:template<typename FuncTy>
        -: 1361:struct on_first {
        -: 1362:  FuncTy func;
        -: 1363:
        -: 1364:  template <typename T>
        -: 1365:  decltype(auto) operator()(const T &lhs, const T &rhs) const {
        -: 1366:    return func(lhs.first, rhs.first);
        -: 1367:  }
        -: 1368:};
        -: 1369:
        -: 1370:/// Utility type to build an inheritance chain that makes it easy to rank
        -: 1371:/// overload candidates.
        -: 1372:template <int N> struct rank : rank<N - 1> {};
        -: 1373:template <> struct rank<0> {};
        -: 1374:
        -: 1375:/// traits class for checking whether type T is one of any of the given
        -: 1376:/// types in the variadic list.
        -: 1377:template <typename T, typename... Ts>
        -: 1378:using is_one_of = disjunction<std::is_same<T, Ts>...>;
        -: 1379:
        -: 1380:/// traits class for checking whether type T is a base class for all
        -: 1381:///  the given types in the variadic list.
        -: 1382:template <typename T, typename... Ts>
        -: 1383:using are_base_of = conjunction<std::is_base_of<T, Ts>...>;
        -: 1384:
        -: 1385:namespace detail {
        -: 1386:template <typename... Ts> struct Visitor;
        -: 1387:
        -: 1388:template <typename HeadT, typename... TailTs>
        -: 1389:struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {
        -: 1390:  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)
        -: 1391:      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),
        -: 1392:        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}
        -: 1393:  using remove_cvref_t<HeadT>::operator();
        -: 1394:  using Visitor<TailTs...>::operator();
        -: 1395:};
        -: 1396:
        -: 1397:template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {
        -: 1398:  explicit constexpr Visitor(HeadT &&Head)
        -: 1399:      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}
        -: 1400:  using remove_cvref_t<HeadT>::operator();
        -: 1401:};
        -: 1402:} // namespace detail
        -: 1403:
        -: 1404:/// Returns an opaquely-typed Callable object whose operator() overload set is
        -: 1405:/// the sum of the operator() overload sets of each CallableT in CallableTs.
        -: 1406:///
        -: 1407:/// The type of the returned object derives from each CallableT in CallableTs.
        -: 1408:/// The returned object is constructed by invoking the appropriate copy or move
        -: 1409:/// constructor of each CallableT, as selected by overload resolution on the
        -: 1410:/// corresponding argument to makeVisitor.
        -: 1411:///
        -: 1412:/// Example:
        -: 1413:///
        -: 1414:/// \code
        -: 1415:/// auto visitor = makeVisitor([](auto) { return "unhandled type"; },
        -: 1416:///                            [](int i) { return "int"; },
        -: 1417:///                            [](std::string s) { return "str"; });
        -: 1418:/// auto a = visitor(42);    // `a` is now "int".
        -: 1419:/// auto b = visitor("foo"); // `b` is now "str".
        -: 1420:/// auto c = visitor(3.14f); // `c` is now "unhandled type".
        -: 1421:/// \endcode
        -: 1422:///
        -: 1423:/// Example of making a visitor with a lambda which captures a move-only type:
        -: 1424:///
        -: 1425:/// \code
        -: 1426:/// std::unique_ptr<FooHandler> FH = /* ... */;
        -: 1427:/// auto visitor = makeVisitor(
        -: 1428:///     [FH{std::move(FH)}](Foo F) { return FH->handle(F); },
        -: 1429:///     [](int i) { return i; },
        -: 1430:///     [](std::string s) { return atoi(s); });
        -: 1431:/// \endcode
        -: 1432:template <typename... CallableTs>
        -: 1433:constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {
        -: 1434:  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);
        -: 1435:}
        -: 1436:
        -: 1437://===----------------------------------------------------------------------===//
        -: 1438://     Extra additions to <algorithm>
        -: 1439://===----------------------------------------------------------------------===//
        -: 1440:
        -: 1441:// We have a copy here so that LLVM behaves the same when using different
        -: 1442:// standard libraries.
        -: 1443:template <class Iterator, class RNG>
        -: 1444:void shuffle(Iterator first, Iterator last, RNG &&g) {
        -: 1445:  // It would be better to use a std::uniform_int_distribution,
        -: 1446:  // but that would be stdlib dependent.
        -: 1447:  typedef
        -: 1448:      typename std::iterator_traits<Iterator>::difference_type difference_type;
        -: 1449:  for (auto size = last - first; size > 1; ++first, (void)--size) {
        -: 1450:    difference_type offset = g() % size;
        -: 1451:    // Avoid self-assignment due to incorrect assertions in libstdc++
        -: 1452:    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).
        -: 1453:    if (offset != difference_type(0))
        -: 1454:      std::iter_swap(first, first + offset);
        -: 1455:  }
        -: 1456:}
        -: 1457:
        -: 1458:/// Adapt std::less<T> for array_pod_sort.
        -: 1459:template<typename T>
        -: 1460:inline int array_pod_sort_comparator(const void *P1, const void *P2) {
        -: 1461:  if (std::less<T>()(*reinterpret_cast<const T*>(P1),
        -: 1462:                     *reinterpret_cast<const T*>(P2)))
        -: 1463:    return -1;
        -: 1464:  if (std::less<T>()(*reinterpret_cast<const T*>(P2),
        -: 1465:                     *reinterpret_cast<const T*>(P1)))
        -: 1466:    return 1;
        -: 1467:  return 0;
        -: 1468:}
        -: 1469:
        -: 1470:/// get_array_pod_sort_comparator - This is an internal helper function used to
        -: 1471:/// get type deduction of T right.
        -: 1472:template<typename T>
        -: 1473:inline int (*get_array_pod_sort_comparator(const T &))
        -: 1474:             (const void*, const void*) {
        -: 1475:  return array_pod_sort_comparator<T>;
        -: 1476:}
        -: 1477:
        -: 1478:#ifdef EXPENSIVE_CHECKS
        -: 1479:namespace detail {
        -: 1480:
        -: 1481:inline unsigned presortShuffleEntropy() {
        -: 1482:  static unsigned Result(std::random_device{}());
        -: 1483:  return Result;
        -: 1484:}
        -: 1485:
        -: 1486:template <class IteratorTy>
        -: 1487:inline void presortShuffle(IteratorTy Start, IteratorTy End) {
        -: 1488:  std::mt19937 Generator(presortShuffleEntropy());
        -: 1489:  llvm::shuffle(Start, End, Generator);
        -: 1490:}
        -: 1491:
        -: 1492:} // end namespace detail
        -: 1493:#endif
        -: 1494:
        -: 1495:/// array_pod_sort - This sorts an array with the specified start and end
        -: 1496:/// extent.  This is just like std::sort, except that it calls qsort instead of
        -: 1497:/// using an inlined template.  qsort is slightly slower than std::sort, but
        -: 1498:/// most sorts are not performance critical in LLVM and std::sort has to be
        -: 1499:/// template instantiated for each type, leading to significant measured code
        -: 1500:/// bloat.  This function should generally be used instead of std::sort where
        -: 1501:/// possible.
        -: 1502:///
        -: 1503:/// This function assumes that you have simple POD-like types that can be
        -: 1504:/// compared with std::less and can be moved with memcpy.  If this isn't true,
        -: 1505:/// you should use std::sort.
        -: 1506:///
        -: 1507:/// NOTE: If qsort_r were portable, we could allow a custom comparator and
        -: 1508:/// default to std::less.
        -: 1509:template<class IteratorTy>
        -: 1510:inline void array_pod_sort(IteratorTy Start, IteratorTy End) {
        -: 1511:  // Don't inefficiently call qsort with one element or trigger undefined
        -: 1512:  // behavior with an empty sequence.
        -: 1513:  auto NElts = End - Start;
        -: 1514:  if (NElts <= 1) return;
        -: 1515:#ifdef EXPENSIVE_CHECKS
        -: 1516:  detail::presortShuffle<IteratorTy>(Start, End);
        -: 1517:#endif
        -: 1518:  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));
        -: 1519:}
        -: 1520:
        -: 1521:template <class IteratorTy>
        -: 1522:inline void array_pod_sort(
        -: 1523:    IteratorTy Start, IteratorTy End,
        -: 1524:    int (*Compare)(
        -: 1525:        const typename std::iterator_traits<IteratorTy>::value_type *,
        -: 1526:        const typename std::iterator_traits<IteratorTy>::value_type *)) {
        -: 1527:  // Don't inefficiently call qsort with one element or trigger undefined
        -: 1528:  // behavior with an empty sequence.
        -: 1529:  auto NElts = End - Start;
        -: 1530:  if (NElts <= 1) return;
        -: 1531:#ifdef EXPENSIVE_CHECKS
        -: 1532:  detail::presortShuffle<IteratorTy>(Start, End);
        -: 1533:#endif
        -: 1534:  qsort(&*Start, NElts, sizeof(*Start),
        -: 1535:        reinterpret_cast<int (*)(const void *, const void *)>(Compare));
        -: 1536:}
        -: 1537:
        -: 1538:namespace detail {
        -: 1539:template <typename T>
        -: 1540:// We can use qsort if the iterator type is a pointer and the underlying value
        -: 1541:// is trivially copyable.
        -: 1542:using sort_trivially_copyable = conjunction<
        -: 1543:    std::is_pointer<T>,
        -: 1544:    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;
        -: 1545:} // namespace detail
        -: 1546:
        -: 1547:// Provide wrappers to std::sort which shuffle the elements before sorting
        -: 1548:// to help uncover non-deterministic behavior (PR35135).
        -: 1549:template <typename IteratorTy,
        -: 1550:          std::enable_if_t<!detail::sort_trivially_copyable<IteratorTy>::value,
        -: 1551:                           int> = 0>
        -: 1552:inline void sort(IteratorTy Start, IteratorTy End) {
        -: 1553:#ifdef EXPENSIVE_CHECKS
        -: 1554:  detail::presortShuffle<IteratorTy>(Start, End);
        -: 1555:#endif
        -: 1556:  std::sort(Start, End);
        -: 1557:}
        -: 1558:
        -: 1559:// Forward trivially copyable types to array_pod_sort. This avoids a large
        -: 1560:// amount of code bloat for a minor performance hit.
        -: 1561:template <typename IteratorTy,
        -: 1562:          std::enable_if_t<detail::sort_trivially_copyable<IteratorTy>::value,
        -: 1563:                           int> = 0>
        -: 1564:inline void sort(IteratorTy Start, IteratorTy End) {
        -: 1565:  array_pod_sort(Start, End);
        -: 1566:}
        -: 1567:
        -: 1568:template <typename Container> inline void sort(Container &&C) {
        -: 1569:  llvm::sort(adl_begin(C), adl_end(C));
        -: 1570:}
        -: 1571:
        -: 1572:template <typename IteratorTy, typename Compare>
        -: 1573:inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {
        -: 1574:#ifdef EXPENSIVE_CHECKS
        -: 1575:  detail::presortShuffle<IteratorTy>(Start, End);
        -: 1576:#endif
        -: 1577:  std::sort(Start, End, Comp);
        -: 1578:}
        -: 1579:
        -: 1580:template <typename Container, typename Compare>
        -: 1581:inline void sort(Container &&C, Compare Comp) {
        -: 1582:  llvm::sort(adl_begin(C), adl_end(C), Comp);
        -: 1583:}
        -: 1584:
        -: 1585:/// Get the size of a range. This is a wrapper function around std::distance
        -: 1586:/// which is only enabled when the operation is O(1).
        -: 1587:template <typename R>
        -: 1588:auto size(R &&Range,
        -: 1589:          std::enable_if_t<
        -: 1590:              std::is_base_of<std::random_access_iterator_tag,
        -: 1591:                              typename std::iterator_traits<decltype(
        -: 1592:                                  Range.begin())>::iterator_category>::value,
        -: 1593:              void> * = nullptr) {
        -: 1594:  return std::distance(Range.begin(), Range.end());
        -: 1595:}
        -: 1596:
        -: 1597:/// Provide wrappers to std::for_each which take ranges instead of having to
        -: 1598:/// pass begin/end explicitly.
        -: 1599:template <typename R, typename UnaryFunction>
        -: 1600:UnaryFunction for_each(R &&Range, UnaryFunction F) {
        -: 1601:  return std::for_each(adl_begin(Range), adl_end(Range), F);
        -: 1602:}
        -: 1603:
        -: 1604:/// Provide wrappers to std::all_of which take ranges instead of having to pass
        -: 1605:/// begin/end explicitly.
        -: 1606:template <typename R, typename UnaryPredicate>
        -: 1607:bool all_of(R &&Range, UnaryPredicate P) {
        -: 1608:  return std::all_of(adl_begin(Range), adl_end(Range), P);
        -: 1609:}
        -: 1610:
        -: 1611:/// Provide wrappers to std::any_of which take ranges instead of having to pass
        -: 1612:/// begin/end explicitly.
        -: 1613:template <typename R, typename UnaryPredicate>
        -: 1614:bool any_of(R &&Range, UnaryPredicate P) {
        -: 1615:  return std::any_of(adl_begin(Range), adl_end(Range), P);
        -: 1616:}
        -: 1617:
        -: 1618:/// Provide wrappers to std::none_of which take ranges instead of having to pass
        -: 1619:/// begin/end explicitly.
        -: 1620:template <typename R, typename UnaryPredicate>
        -: 1621:bool none_of(R &&Range, UnaryPredicate P) {
        -: 1622:  return std::none_of(adl_begin(Range), adl_end(Range), P);
        -: 1623:}
        -: 1624:
        -: 1625:/// Provide wrappers to std::find which take ranges instead of having to pass
        -: 1626:/// begin/end explicitly.
        -: 1627:template <typename R, typename T> auto find(R &&Range, const T &Val) {
        -: 1628:  return std::find(adl_begin(Range), adl_end(Range), Val);
        -: 1629:}
        -: 1630:
        -: 1631:/// Provide wrappers to std::find_if which take ranges instead of having to pass
        -: 1632:/// begin/end explicitly.
        -: 1633:template <typename R, typename UnaryPredicate>
        -: 1634:auto find_if(R &&Range, UnaryPredicate P) {
        -: 1635:  return std::find_if(adl_begin(Range), adl_end(Range), P);
        -: 1636:}
        -: 1637:
        -: 1638:template <typename R, typename UnaryPredicate>
        -: 1639:auto find_if_not(R &&Range, UnaryPredicate P) {
        -: 1640:  return std::find_if_not(adl_begin(Range), adl_end(Range), P);
        -: 1641:}
        -: 1642:
        -: 1643:/// Provide wrappers to std::remove_if which take ranges instead of having to
        -: 1644:/// pass begin/end explicitly.
        -: 1645:template <typename R, typename UnaryPredicate>
        -: 1646:auto remove_if(R &&Range, UnaryPredicate P) {
        -: 1647:  return std::remove_if(adl_begin(Range), adl_end(Range), P);
        -: 1648:}
        -: 1649:
        -: 1650:/// Provide wrappers to std::copy_if which take ranges instead of having to
        -: 1651:/// pass begin/end explicitly.
        -: 1652:template <typename R, typename OutputIt, typename UnaryPredicate>
        -: 1653:OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {
        -: 1654:  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);
        -: 1655:}
        -: 1656:
        -: 1657:template <typename R, typename OutputIt>
        -: 1658:OutputIt copy(R &&Range, OutputIt Out) {
        -: 1659:  return std::copy(adl_begin(Range), adl_end(Range), Out);
        -: 1660:}
        -: 1661:
        -: 1662:/// Provide wrappers to std::move which take ranges instead of having to
        -: 1663:/// pass begin/end explicitly.
        -: 1664:template <typename R, typename OutputIt>
        -: 1665:OutputIt move(R &&Range, OutputIt Out) {
        -: 1666:  return std::move(adl_begin(Range), adl_end(Range), Out);
        -: 1667:}
        -: 1668:
        -: 1669:/// Wrapper function around std::find to detect if an element exists
        -: 1670:/// in a container.
        -: 1671:template <typename R, typename E>
        8: 1672:bool is_contained(R &&Range, const E &Element) {
        8: 1673:  return std::find(adl_begin(Range), adl_end(Range), Element) != adl_end(Range);
        -: 1674:}
        -: 1675:
        -: 1676:template <typename T>
        -: 1677:constexpr bool is_contained(std::initializer_list<T> Set, T Value) {
        -: 1678:  // TODO: Use std::find when we switch to C++20.
        -: 1679:  for (T V : Set)
        -: 1680:    if (V == Value)
        -: 1681:      return true;
        -: 1682:  return false;
        -: 1683:}
        -: 1684:
        -: 1685:/// Wrapper function around std::is_sorted to check if elements in a range \p R
        -: 1686:/// are sorted with respect to a comparator \p C.
        -: 1687:template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {
        -: 1688:  return std::is_sorted(adl_begin(Range), adl_end(Range), C);
        -: 1689:}
        -: 1690:
        -: 1691:/// Wrapper function around std::is_sorted to check if elements in a range \p R
        -: 1692:/// are sorted in non-descending order.
        -: 1693:template <typename R> bool is_sorted(R &&Range) {
        -: 1694:  return std::is_sorted(adl_begin(Range), adl_end(Range));
        -: 1695:}
        -: 1696:
        -: 1697:/// Wrapper function around std::count to count the number of times an element
        -: 1698:/// \p Element occurs in the given range \p Range.
        -: 1699:template <typename R, typename E> auto count(R &&Range, const E &Element) {
        -: 1700:  return std::count(adl_begin(Range), adl_end(Range), Element);
        -: 1701:}
        -: 1702:
        -: 1703:/// Wrapper function around std::count_if to count the number of times an
        -: 1704:/// element satisfying a given predicate occurs in a range.
        -: 1705:template <typename R, typename UnaryPredicate>
        -: 1706:auto count_if(R &&Range, UnaryPredicate P) {
        -: 1707:  return std::count_if(adl_begin(Range), adl_end(Range), P);
        -: 1708:}
        -: 1709:
        -: 1710:/// Wrapper function around std::transform to apply a function to a range and
        -: 1711:/// store the result elsewhere.
        -: 1712:template <typename R, typename OutputIt, typename UnaryFunction>
        -: 1713:OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {
        -: 1714:  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);
        -: 1715:}
        -: 1716:
        -: 1717:/// Provide wrappers to std::partition which take ranges instead of having to
        -: 1718:/// pass begin/end explicitly.
        -: 1719:template <typename R, typename UnaryPredicate>
        -: 1720:auto partition(R &&Range, UnaryPredicate P) {
        -: 1721:  return std::partition(adl_begin(Range), adl_end(Range), P);
        -: 1722:}
        -: 1723:
        -: 1724:/// Provide wrappers to std::lower_bound which take ranges instead of having to
        -: 1725:/// pass begin/end explicitly.
        -: 1726:template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {
        -: 1727:  return std::lower_bound(adl_begin(Range), adl_end(Range),
        -: 1728:                          std::forward<T>(Value));
        -: 1729:}
        -: 1730:
        -: 1731:template <typename R, typename T, typename Compare>
        -: 1732:auto lower_bound(R &&Range, T &&Value, Compare C) {
        -: 1733:  return std::lower_bound(adl_begin(Range), adl_end(Range),
        -: 1734:                          std::forward<T>(Value), C);
        -: 1735:}
        -: 1736:
        -: 1737:/// Provide wrappers to std::upper_bound which take ranges instead of having to
        -: 1738:/// pass begin/end explicitly.
        -: 1739:template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {
        -: 1740:  return std::upper_bound(adl_begin(Range), adl_end(Range),
        -: 1741:                          std::forward<T>(Value));
        -: 1742:}
        -: 1743:
        -: 1744:template <typename R, typename T, typename Compare>
        -: 1745:auto upper_bound(R &&Range, T &&Value, Compare C) {
        -: 1746:  return std::upper_bound(adl_begin(Range), adl_end(Range),
        -: 1747:                          std::forward<T>(Value), C);
        -: 1748:}
        -: 1749:
        -: 1750:template <typename R>
        -: 1751:void stable_sort(R &&Range) {
        -: 1752:  std::stable_sort(adl_begin(Range), adl_end(Range));
        -: 1753:}
        -: 1754:
        -: 1755:template <typename R, typename Compare>
        -: 1756:void stable_sort(R &&Range, Compare C) {
        -: 1757:  std::stable_sort(adl_begin(Range), adl_end(Range), C);
        -: 1758:}
        -: 1759:
        -: 1760:/// Binary search for the first iterator in a range where a predicate is false.
        -: 1761:/// Requires that C is always true below some limit, and always false above it.
        -: 1762:template <typename R, typename Predicate,
        -: 1763:          typename Val = decltype(*adl_begin(std::declval<R>()))>
        -: 1764:auto partition_point(R &&Range, Predicate P) {
        -: 1765:  return std::partition_point(adl_begin(Range), adl_end(Range), P);
        -: 1766:}
        -: 1767:
        -: 1768:template<typename Range, typename Predicate>
        -: 1769:auto unique(Range &&R, Predicate P) {
        -: 1770:  return std::unique(adl_begin(R), adl_end(R), P);
        -: 1771:}
        -: 1772:
        -: 1773:/// Wrapper function around std::equal to detect if pair-wise elements between
        -: 1774:/// two ranges are the same.
        -: 1775:template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {
        -: 1776:  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),
        -: 1777:                    adl_end(RRange));
        -: 1778:}
        -: 1779:
        -: 1780:/// Wrapper function around std::equal to detect if all elements
        -: 1781:/// in a container are same.
        -: 1782:template <typename R>
        -: 1783:bool is_splat(R &&Range) {
        -: 1784:  size_t range_size = size(Range);
        -: 1785:  return range_size != 0 && (range_size == 1 ||
        -: 1786:         std::equal(adl_begin(Range) + 1, adl_end(Range), adl_begin(Range)));
        -: 1787:}
        -: 1788:
        -: 1789:/// Provide a container algorithm similar to C++ Library Fundamentals v2's
        -: 1790:/// `erase_if` which is equivalent to:
        -: 1791:///
        -: 1792:///   C.erase(remove_if(C, pred), C.end());
        -: 1793:///
        -: 1794:/// This version works for any container with an erase method call accepting
        -: 1795:/// two iterators.
        -: 1796:template <typename Container, typename UnaryPredicate>
        -: 1797:void erase_if(Container &C, UnaryPredicate P) {
        -: 1798:  C.erase(remove_if(C, P), C.end());
        -: 1799:}
        -: 1800:
        -: 1801:/// Wrapper function to remove a value from a container:
        -: 1802:///
        -: 1803:/// C.erase(remove(C.begin(), C.end(), V), C.end());
        -: 1804:template <typename Container, typename ValueType>
        -: 1805:void erase_value(Container &C, ValueType V) {
        -: 1806:  C.erase(std::remove(C.begin(), C.end(), V), C.end());
        -: 1807:}
        -: 1808:
        -: 1809:/// Wrapper function to append a range to a container.
        -: 1810:///
        -: 1811:/// C.insert(C.end(), R.begin(), R.end());
        -: 1812:template <typename Container, typename Range>
        -: 1813:inline void append_range(Container &C, Range &&R) {
        -: 1814:  C.insert(C.end(), R.begin(), R.end());
        -: 1815:}
        -: 1816:
        -: 1817:/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with
        -: 1818:/// the range [ValIt, ValEnd) (which is not from the same container).
        -: 1819:template<typename Container, typename RandomAccessIterator>
        -: 1820:void replace(Container &Cont, typename Container::iterator ContIt,
        -: 1821:             typename Container::iterator ContEnd, RandomAccessIterator ValIt,
        -: 1822:             RandomAccessIterator ValEnd) {
        -: 1823:  while (true) {
        -: 1824:    if (ValIt == ValEnd) {
        -: 1825:      Cont.erase(ContIt, ContEnd);
        -: 1826:      return;
        -: 1827:    } else if (ContIt == ContEnd) {
        -: 1828:      Cont.insert(ContIt, ValIt, ValEnd);
        -: 1829:      return;
        -: 1830:    }
        -: 1831:    *ContIt++ = *ValIt++;
        -: 1832:  }
        -: 1833:}
        -: 1834:
        -: 1835:/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with
        -: 1836:/// the range R.
        -: 1837:template<typename Container, typename Range = std::initializer_list<
        -: 1838:                                 typename Container::value_type>>
        -: 1839:void replace(Container &Cont, typename Container::iterator ContIt,
        -: 1840:             typename Container::iterator ContEnd, Range R) {
        -: 1841:  replace(Cont, ContIt, ContEnd, R.begin(), R.end());
        -: 1842:}
        -: 1843:
        -: 1844:/// An STL-style algorithm similar to std::for_each that applies a second
        -: 1845:/// functor between every pair of elements.
        -: 1846:///
        -: 1847:/// This provides the control flow logic to, for example, print a
        -: 1848:/// comma-separated list:
        -: 1849:/// \code
        -: 1850:///   interleave(names.begin(), names.end(),
        -: 1851:///              [&](StringRef name) { os << name; },
        -: 1852:///              [&] { os << ", "; });
        -: 1853:/// \endcode
        -: 1854:template <typename ForwardIterator, typename UnaryFunctor,
        -: 1855:          typename NullaryFunctor,
        -: 1856:          typename = typename std::enable_if<
        -: 1857:              !std::is_constructible<StringRef, UnaryFunctor>::value &&
        -: 1858:              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>
        -: 1859:inline void interleave(ForwardIterator begin, ForwardIterator end,
        -: 1860:                       UnaryFunctor each_fn, NullaryFunctor between_fn) {
        -: 1861:  if (begin == end)
        -: 1862:    return;
        -: 1863:  each_fn(*begin);
        -: 1864:  ++begin;
        -: 1865:  for (; begin != end; ++begin) {
        -: 1866:    between_fn();
        -: 1867:    each_fn(*begin);
        -: 1868:  }
        -: 1869:}
        -: 1870:
        -: 1871:template <typename Container, typename UnaryFunctor, typename NullaryFunctor,
        -: 1872:          typename = typename std::enable_if<
        -: 1873:              !std::is_constructible<StringRef, UnaryFunctor>::value &&
        -: 1874:              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>
        -: 1875:inline void interleave(const Container &c, UnaryFunctor each_fn,
        -: 1876:                       NullaryFunctor between_fn) {
        -: 1877:  interleave(c.begin(), c.end(), each_fn, between_fn);
        -: 1878:}
        -: 1879:
        -: 1880:/// Overload of interleave for the common case of string separator.
        -: 1881:template <typename Container, typename UnaryFunctor, typename StreamT,
        -: 1882:          typename T = detail::ValueOfRange<Container>>
        -: 1883:inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,
        -: 1884:                       const StringRef &separator) {
        -: 1885:  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });
        -: 1886:}
        -: 1887:template <typename Container, typename StreamT,
        -: 1888:          typename T = detail::ValueOfRange<Container>>
        -: 1889:inline void interleave(const Container &c, StreamT &os,
        -: 1890:                       const StringRef &separator) {
        -: 1891:  interleave(
        -: 1892:      c, os, [&](const T &a) { os << a; }, separator);
        -: 1893:}
        -: 1894:
        -: 1895:template <typename Container, typename UnaryFunctor, typename StreamT,
        -: 1896:          typename T = detail::ValueOfRange<Container>>
        -: 1897:inline void interleaveComma(const Container &c, StreamT &os,
        -: 1898:                            UnaryFunctor each_fn) {
        -: 1899:  interleave(c, os, each_fn, ", ");
        -: 1900:}
        -: 1901:template <typename Container, typename StreamT,
        -: 1902:          typename T = detail::ValueOfRange<Container>>
        -: 1903:inline void interleaveComma(const Container &c, StreamT &os) {
        -: 1904:  interleaveComma(c, os, [&](const T &a) { os << a; });
        -: 1905:}
        -: 1906:
        -: 1907://===----------------------------------------------------------------------===//
        -: 1908://     Extra additions to <memory>
        -: 1909://===----------------------------------------------------------------------===//
        -: 1910:
        -: 1911:struct FreeDeleter {
        -: 1912:  void operator()(void* v) {
        -: 1913:    ::free(v);
        -: 1914:  }
        -: 1915:};
        -: 1916:
        -: 1917:template<typename First, typename Second>
        -: 1918:struct pair_hash {
        -: 1919:  size_t operator()(const std::pair<First, Second> &P) const {
        -: 1920:    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);
        -: 1921:  }
        -: 1922:};
        -: 1923:
        -: 1924:/// Binary functor that adapts to any other binary functor after dereferencing
        -: 1925:/// operands.
        -: 1926:template <typename T> struct deref {
        -: 1927:  T func;
        -: 1928:
        -: 1929:  // Could be further improved to cope with non-derivable functors and
        -: 1930:  // non-binary functors (should be a variadic template member function
        -: 1931:  // operator()).
        -: 1932:  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {
        -: 1933:    assert(lhs);
        -: 1934:    assert(rhs);
        -: 1935:    return func(*lhs, *rhs);
        -: 1936:  }
        -: 1937:};
        -: 1938:
        -: 1939:namespace detail {
        -: 1940:
        -: 1941:template <typename R> class enumerator_iter;
        -: 1942:
        -: 1943:template <typename R> struct result_pair {
        -: 1944:  using value_reference =
        -: 1945:      typename std::iterator_traits<IterOfRange<R>>::reference;
        -: 1946:
        -: 1947:  friend class enumerator_iter<R>;
        -: 1948:
        -: 1949:  result_pair() = default;
        -: 1950:  result_pair(std::size_t Index, IterOfRange<R> Iter)
        -: 1951:      : Index(Index), Iter(Iter) {}
        -: 1952:
        -: 1953:  result_pair(const result_pair<R> &Other)
        -: 1954:      : Index(Other.Index), Iter(Other.Iter) {}
        -: 1955:  result_pair &operator=(const result_pair &Other) {
        -: 1956:    Index = Other.Index;
        -: 1957:    Iter = Other.Iter;
        -: 1958:    return *this;
        -: 1959:  }
        -: 1960:
        -: 1961:  std::size_t index() const { return Index; }
        -: 1962:  value_reference value() const { return *Iter; }
        -: 1963:
        -: 1964:private:
        -: 1965:  std::size_t Index = std::numeric_limits<std::size_t>::max();
        -: 1966:  IterOfRange<R> Iter;
        -: 1967:};
        -: 1968:
        -: 1969:template <typename R>
        -: 1970:class enumerator_iter
        -: 1971:    : public iterator_facade_base<enumerator_iter<R>, std::forward_iterator_tag,
        -: 1972:                                  const result_pair<R>> {
        -: 1973:  using result_type = result_pair<R>;
        -: 1974:
        -: 1975:public:
        -: 1976:  explicit enumerator_iter(IterOfRange<R> EndIter)
        -: 1977:      : Result(std::numeric_limits<size_t>::max(), EndIter) {}
        -: 1978:
        -: 1979:  enumerator_iter(std::size_t Index, IterOfRange<R> Iter)
        -: 1980:      : Result(Index, Iter) {}
        -: 1981:
        -: 1982:  const result_type &operator*() const { return Result; }
        -: 1983:
        -: 1984:  enumerator_iter &operator++() {
        -: 1985:    assert(Result.Index != std::numeric_limits<size_t>::max());
        -: 1986:    ++Result.Iter;
        -: 1987:    ++Result.Index;
        -: 1988:    return *this;
        -: 1989:  }
        -: 1990:
        -: 1991:  bool operator==(const enumerator_iter &RHS) const {
        -: 1992:    // Don't compare indices here, only iterators.  It's possible for an end
        -: 1993:    // iterator to have different indices depending on whether it was created
        -: 1994:    // by calling std::end() versus incrementing a valid iterator.
        -: 1995:    return Result.Iter == RHS.Result.Iter;
        -: 1996:  }
        -: 1997:
        -: 1998:  enumerator_iter(const enumerator_iter &Other) : Result(Other.Result) {}
        -: 1999:  enumerator_iter &operator=(const enumerator_iter &Other) {
        -: 2000:    Result = Other.Result;
        -: 2001:    return *this;
        -: 2002:  }
        -: 2003:
        -: 2004:private:
        -: 2005:  result_type Result;
        -: 2006:};
        -: 2007:
        -: 2008:template <typename R> class enumerator {
        -: 2009:public:
        -: 2010:  explicit enumerator(R &&Range) : TheRange(std::forward<R>(Range)) {}
        -: 2011:
        -: 2012:  enumerator_iter<R> begin() {
        -: 2013:    return enumerator_iter<R>(0, std::begin(TheRange));
        -: 2014:  }
        -: 2015:  enumerator_iter<R> begin() const {
        -: 2016:    return enumerator_iter<R>(0, std::begin(TheRange));
        -: 2017:  }
        -: 2018:
        -: 2019:  enumerator_iter<R> end() {
        -: 2020:    return enumerator_iter<R>(std::end(TheRange));
        -: 2021:  }
        -: 2022:  enumerator_iter<R> end() const {
        -: 2023:    return enumerator_iter<R>(std::end(TheRange));
        -: 2024:  }
        -: 2025:
        -: 2026:private:
        -: 2027:  R TheRange;
        -: 2028:};
        -: 2029:
        -: 2030:} // end namespace detail
        -: 2031:
        -: 2032:/// Given an input range, returns a new range whose values are are pair (A,B)
        -: 2033:/// such that A is the 0-based index of the item in the sequence, and B is
        -: 2034:/// the value from the original sequence.  Example:
        -: 2035:///
        -: 2036:/// std::vector<char> Items = {'A', 'B', 'C', 'D'};
        -: 2037:/// for (auto X : enumerate(Items)) {
        -: 2038:///   printf("Item %d - %c\n", X.index(), X.value());
        -: 2039:/// }
        -: 2040:///
        -: 2041:/// Output:
        -: 2042:///   Item 0 - A
        -: 2043:///   Item 1 - B
        -: 2044:///   Item 2 - C
        -: 2045:///   Item 3 - D
        -: 2046:///
        -: 2047:template <typename R> detail::enumerator<R> enumerate(R &&TheRange) {
        -: 2048:  return detail::enumerator<R>(std::forward<R>(TheRange));
        -: 2049:}
        -: 2050:
        -: 2051:namespace detail {
        -: 2052:
        -: 2053:template <typename F, typename Tuple, std::size_t... I>
        -: 2054:decltype(auto) apply_tuple_impl(F &&f, Tuple &&t, std::index_sequence<I...>) {
        -: 2055:  return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);
        -: 2056:}
        -: 2057:
        -: 2058:} // end namespace detail
        -: 2059:
        -: 2060:/// Given an input tuple (a1, a2, ..., an), pass the arguments of the
        -: 2061:/// tuple variadically to f as if by calling f(a1, a2, ..., an) and
        -: 2062:/// return the result.
        -: 2063:template <typename F, typename Tuple>
        -: 2064:decltype(auto) apply_tuple(F &&f, Tuple &&t) {
        -: 2065:  using Indices = std::make_index_sequence<
        -: 2066:      std::tuple_size<typename std::decay<Tuple>::type>::value>;
        -: 2067:
        -: 2068:  return detail::apply_tuple_impl(std::forward<F>(f), std::forward<Tuple>(t),
        -: 2069:                                  Indices{});
        -: 2070:}
        -: 2071:
        -: 2072:namespace detail {
        -: 2073:
        -: 2074:template <typename Predicate, typename... Args>
        -: 2075:bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {
        -: 2076:  auto z = zip(args...);
        -: 2077:  auto it = z.begin();
        -: 2078:  auto end = z.end();
        -: 2079:  while (it != end) {
        -: 2080:    if (!apply_tuple([&](auto &&...args) { return P(args...); }, *it))
        -: 2081:      return false;
        -: 2082:    ++it;
        -: 2083:  }
        -: 2084:  return it.all_equals(end);
        -: 2085:}
        -: 2086:
        -: 2087:// Just an adaptor to switch the order of argument and have the predicate before
        -: 2088:// the zipped inputs.
        -: 2089:template <typename... ArgsThenPredicate, size_t... InputIndexes>
        -: 2090:bool all_of_zip_predicate_last(
        -: 2091:    std::tuple<ArgsThenPredicate...> argsThenPredicate,
        -: 2092:    std::index_sequence<InputIndexes...>) {
        -: 2093:  auto constexpr OutputIndex =
        -: 2094:      std::tuple_size<decltype(argsThenPredicate)>::value - 1;
        -: 2095:  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),
        -: 2096:                             std::get<InputIndexes>(argsThenPredicate)...);
        -: 2097:}
        -: 2098:
        -: 2099:} // end namespace detail
        -: 2100:
        -: 2101:/// Compare two zipped ranges using the provided predicate (as last argument).
        -: 2102:/// Return true if all elements satisfy the predicate and false otherwise.
        -: 2103://  Return false if the zipped iterator aren't all at end (size mismatch).
        -: 2104:template <typename... ArgsAndPredicate>
        -: 2105:bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {
        -: 2106:  return detail::all_of_zip_predicate_last(
        -: 2107:      std::forward_as_tuple(argsAndPredicate...),
        -: 2108:      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});
        -: 2109:}
        -: 2110:
        -: 2111:/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)
        -: 2112:/// time. Not meant for use with random-access iterators.
        -: 2113:/// Can optionally take a predicate to filter lazily some items.
        -: 2114:template <typename IterTy,
        -: 2115:          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
        -: 2116:bool hasNItems(
        -: 2117:    IterTy &&Begin, IterTy &&End, unsigned N,
        -: 2118:    Pred &&ShouldBeCounted =
        -: 2119:        [](const decltype(*std::declval<IterTy>()) &) { return true; },
        -: 2120:    std::enable_if_t<
        -: 2121:        !std::is_base_of<std::random_access_iterator_tag,
        -: 2122:                         typename std::iterator_traits<std::remove_reference_t<
        -: 2123:                             decltype(Begin)>>::iterator_category>::value,
        -: 2124:        void> * = nullptr) {
        -: 2125:  for (; N; ++Begin) {
        -: 2126:    if (Begin == End)
        -: 2127:      return false; // Too few.
        -: 2128:    N -= ShouldBeCounted(*Begin);
        -: 2129:  }
        -: 2130:  for (; Begin != End; ++Begin)
        -: 2131:    if (ShouldBeCounted(*Begin))
        -: 2132:      return false; // Too many.
        -: 2133:  return true;
        -: 2134:}
        -: 2135:
        -: 2136:/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)
        -: 2137:/// time. Not meant for use with random-access iterators.
        -: 2138:/// Can optionally take a predicate to lazily filter some items.
        -: 2139:template <typename IterTy,
        -: 2140:          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
        -: 2141:bool hasNItemsOrMore(
        -: 2142:    IterTy &&Begin, IterTy &&End, unsigned N,
        -: 2143:    Pred &&ShouldBeCounted =
        -: 2144:        [](const decltype(*std::declval<IterTy>()) &) { return true; },
        -: 2145:    std::enable_if_t<
        -: 2146:        !std::is_base_of<std::random_access_iterator_tag,
        -: 2147:                         typename std::iterator_traits<std::remove_reference_t<
        -: 2148:                             decltype(Begin)>>::iterator_category>::value,
        -: 2149:        void> * = nullptr) {
        -: 2150:  for (; N; ++Begin) {
        -: 2151:    if (Begin == End)
        -: 2152:      return false; // Too few.
        -: 2153:    N -= ShouldBeCounted(*Begin);
        -: 2154:  }
        -: 2155:  return true;
        -: 2156:}
        -: 2157:
        -: 2158:/// Returns true if the sequence [Begin, End) has N or less items. Can
        -: 2159:/// optionally take a predicate to lazily filter some items.
        -: 2160:template <typename IterTy,
        -: 2161:          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
        -: 2162:bool hasNItemsOrLess(
        -: 2163:    IterTy &&Begin, IterTy &&End, unsigned N,
        -: 2164:    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {
        -: 2165:      return true;
        -: 2166:    }) {
        -: 2167:  assert(N != std::numeric_limits<unsigned>::max());
        -: 2168:  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);
        -: 2169:}
        -: 2170:
        -: 2171:/// Returns true if the given container has exactly N items
        -: 2172:template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {
        -: 2173:  return hasNItems(std::begin(C), std::end(C), N);
        -: 2174:}
        -: 2175:
        -: 2176:/// Returns true if the given container has N or more items
        -: 2177:template <typename ContainerTy>
        -: 2178:bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {
        -: 2179:  return hasNItemsOrMore(std::begin(C), std::end(C), N);
        -: 2180:}
        -: 2181:
        -: 2182:/// Returns true if the given container has N or less items
        -: 2183:template <typename ContainerTy>
        -: 2184:bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {
        -: 2185:  return hasNItemsOrLess(std::begin(C), std::end(C), N);
        -: 2186:}
        -: 2187:
        -: 2188:/// Returns a raw pointer that represents the same address as the argument.
        -: 2189:///
        -: 2190:/// This implementation can be removed once we move to C++20 where it's defined
        -: 2191:/// as std::to_address().
        -: 2192:///
        -: 2193:/// The std::pointer_traits<>::to_address(p) variations of these overloads has
        -: 2194:/// not been implemented.
        -: 2195:template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }
        -: 2196:template <class T> constexpr T *to_address(T *P) { return P; }
        -: 2197:
        -: 2198:} // end namespace llvm
        -: 2199:
        -: 2200:#endif // LLVM_ADT_STLEXTRAS_H
