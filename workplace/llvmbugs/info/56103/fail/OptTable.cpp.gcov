        -:    0:Source:/data1/lyj/llvm-compilers/be6af89f85ebd04646b5704301470f02b70a0447-src/llvm/lib/Option/OptTable.cpp
        -:    0:Graph:/data1/lyj/llvm-compilers//be6af89f85ebd04646b5704301470f02b70a0447-build/lib/Option/CMakeFiles/LLVMOption.dir/OptTable.cpp.gcno
        -:    0:Data:/data1/lyj/llvm-compilers//be6af89f85ebd04646b5704301470f02b70a0447-build/lib/Option/CMakeFiles/LLVMOption.dir/OptTable.cpp.gcda
        -:    0:Runs:2
        -:    1://===- OptTable.cpp - Option Table Implementation -------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "llvm/Option/OptTable.h"
        -:   10:#include "llvm/ADT/STLExtras.h"
        -:   11:#include "llvm/ADT/StringRef.h"
        -:   12:#include "llvm/ADT/StringSet.h"
        -:   13:#include "llvm/Option/Arg.h"
        -:   14:#include "llvm/Option/ArgList.h"
        -:   15:#include "llvm/Option/OptSpecifier.h"
        -:   16:#include "llvm/Option/Option.h"
        -:   17:#include "llvm/Support/CommandLine.h" // for expandResponseFiles
        -:   18:#include "llvm/Support/Compiler.h"
        -:   19:#include "llvm/Support/ErrorHandling.h"
        -:   20:#include "llvm/Support/raw_ostream.h"
        -:   21:#include <algorithm>
        -:   22:#include <cassert>
        -:   23:#include <cctype>
        -:   24:#include <cstring>
        -:   25:#include <map>
        -:   26:#include <string>
        -:   27:#include <utility>
        -:   28:#include <vector>
        -:   29:
        -:   30:using namespace llvm;
        -:   31:using namespace llvm::opt;
        -:   32:
        -:   33:namespace llvm {
        -:   34:namespace opt {
        -:   35:
        -:   36:// Ordering on Info. The ordering is *almost* case-insensitive lexicographic,
        -:   37:// with an exception. '\0' comes at the end of the alphabet instead of the
        -:   38:// beginning (thus options precede any other options which prefix them).
    12451:   39:static int StrCmpOptionNameIgnoreCase(const char *A, const char *B) {
    12451:   40:  const char *X = A, *Y = B;
    12451:   41:  char a = tolower(*A), b = tolower(*B);
    32615:   42:  while (a == b) {
    21193:   43:    if (a == '\0')
        -:   44:      return 0;
        -:   45:
    20164:   46:    a = tolower(*++X);
    20164:   47:    b = tolower(*++Y);
        -:   48:  }
        -:   49:
    11422:   50:  if (a == '\0') // A is a prefix of B.
        -:   51:    return 1;
    11401:   52:  if (b == '\0') // B is a prefix of A.
        -:   53:    return -1;
        -:   54:
        -:   55:  // Otherwise lexicographic.
    11390:   56:  return (a < b) ? -1 : 1;
        -:   57:}
        -:   58:
        -:   59:#ifndef NDEBUG
        -:   60:static int StrCmpOptionName(const char *A, const char *B) {
        -:   61:  if (int N = StrCmpOptionNameIgnoreCase(A, B))
        -:   62:    return N;
        -:   63:  return strcmp(A, B);
        -:   64:}
        -:   65:
        -:   66:static inline bool operator<(const OptTable::Info &A, const OptTable::Info &B) {
        -:   67:  if (&A == &B)
        -:   68:    return false;
        -:   69:
        -:   70:  if (int N = StrCmpOptionName(A.Name, B.Name))
        -:   71:    return N < 0;
        -:   72:
        -:   73:  for (const char * const *APre = A.Prefixes,
        -:   74:                  * const *BPre = B.Prefixes;
        -:   75:                          *APre != nullptr && *BPre != nullptr; ++APre, ++BPre){
        -:   76:    if (int N = StrCmpOptionName(*APre, *BPre))
        -:   77:      return N < 0;
        -:   78:  }
        -:   79:
        -:   80:  // Names are the same, check that classes are in order; exactly one
        -:   81:  // should be joined, and it should succeed the other.
        -:   82:  assert(((A.Kind == Option::JoinedClass) ^ (B.Kind == Option::JoinedClass)) &&
        -:   83:         "Unexpected classes for options with same name.");
        -:   84:  return B.Kind == Option::JoinedClass;
        -:   85:}
        -:   86:#endif
        -:   87:
        -:   88:// Support lower_bound between info and an option name.
    12451:   89:static inline bool operator<(const OptTable::Info &I, const char *Name) {
    12451:   90:  return StrCmpOptionNameIgnoreCase(I.Name, Name) < 0;
        -:   91:}
        -:   92:
        -:   93:} // end namespace opt
        -:   94:} // end namespace llvm
        -:   95:
    #####:   96:OptSpecifier::OptSpecifier(const Option *Opt) : ID(Opt->getID()) {}
        -:   97:
        2:   98:OptTable::OptTable(ArrayRef<Info> OptionInfos, bool IgnoreCase)
        2:   99:    : OptionInfos(OptionInfos), IgnoreCase(IgnoreCase) {
        -:  100:  // Explicitly zero initialize the error to work around a bug in array
        -:  101:  // value-initialization on MinGW with gcc 4.3.5.
        -:  102:
        -:  103:  // Find start of normal options.
      126:  104:  for (unsigned i = 0, e = getNumOptions(); i != e; ++i) {
      126:  105:    unsigned Kind = getInfo(i + 1).Kind;
      126:  106:    if (Kind == Option::InputClass) {
        2:  107:      assert(!InputOptionID && "Cannot have multiple input options!");
        2:  108:      InputOptionID = getInfo(i + 1).ID;
      124:  109:    } else if (Kind == Option::UnknownClass) {
        2:  110:      assert(!UnknownOptionID && "Cannot have multiple unknown options!");
        2:  111:      UnknownOptionID = getInfo(i + 1).ID;
      122:  112:    } else if (Kind != Option::GroupClass) {
        2:  113:      FirstSearchableIndex = i;
        2:  114:      break;
        -:  115:    }
        -:  116:  }
        2:  117:  assert(FirstSearchableIndex != 0 && "No searchable options?");
        -:  118:
        -:  119:#ifndef NDEBUG
        -:  120:  // Check that everything after the first searchable option is a
        -:  121:  // regular option class.
        -:  122:  for (unsigned i = FirstSearchableIndex, e = getNumOptions(); i != e; ++i) {
        -:  123:    Option::OptionClass Kind = (Option::OptionClass) getInfo(i + 1).Kind;
        -:  124:    assert((Kind != Option::InputClass && Kind != Option::UnknownClass &&
        -:  125:            Kind != Option::GroupClass) &&
        -:  126:           "Special options should be defined first!");
        -:  127:  }
        -:  128:
        -:  129:  // Check that options are in order.
        -:  130:  for (unsigned i = FirstSearchableIndex + 1, e = getNumOptions(); i != e; ++i){
        -:  131:    if (!(getInfo(i) < getInfo(i + 1))) {
        -:  132:      getOption(i).dump();
        -:  133:      getOption(i + 1).dump();
        -:  134:      llvm_unreachable("Options are not in order!");
        -:  135:    }
        -:  136:  }
        -:  137:#endif
        -:  138:
        -:  139:  // Build prefixes.
     5938:  140:  for (unsigned i = FirstSearchableIndex + 1, e = getNumOptions() + 1;
     5938:  141:                i != e; ++i) {
     5936:  142:    if (const char *const *P = getInfo(i).Prefixes) {
    12508:  143:      for (; *P != nullptr; ++P) {
     6572:  144:        PrefixesUnion.insert(*P);
        -:  145:      }
        -:  146:    }
        -:  147:  }
        -:  148:
        -:  149:  // Build prefix chars.
       10:  150:  for (StringSet<>::const_iterator I = PrefixesUnion.begin(),
        8:  151:                                   E = PrefixesUnion.end(); I != E; ++I) {
        6:  152:    StringRef Prefix = I->getKey();
       14:  153:    for (char C : Prefix)
        8:  154:      if (!is_contained(PrefixChars, C))
        4:  155:        PrefixChars.push_back(C);
        -:  156:  }
        2:  157:}
        -:  158:
    #####:  159:OptTable::~OptTable() = default;
        -:  160:
    48180:  161:const Option OptTable::getOption(OptSpecifier Opt) const {
    48180:  162:  unsigned id = Opt.getID();
    48180:  163:  if (id == 0)
    47784:  164:    return Option(nullptr, nullptr);
      396:  165:  assert((unsigned) (id - 1) < getNumOptions() && "Invalid ID.");
      396:  166:  return Option(&getInfo(id), this);
        -:  167:}
        -:  168:
     1039:  169:static bool isInput(const StringSet<> &Prefixes, StringRef Arg) {
     1039:  170:  if (Arg == "-")
        -:  171:    return true;
     2080:  172:  for (StringSet<>::const_iterator I = Prefixes.begin(),
     2080:  173:                                   E = Prefixes.end(); I != E; ++I)
     2080:  174:    if (Arg.startswith(I->getKey()))
     1039:  175:      return false;
        -:  176:  return true;
        -:  177:}
        -:  178:
        -:  179:/// \returns Matched size. 0 means no match.
     9560:  180:static unsigned matchOption(const OptTable::Info *I, StringRef Str,
        -:  181:                            bool IgnoreCase) {
    18996:  182:  for (const char * const *Pre = I->Prefixes; *Pre != nullptr; ++Pre) {
    10477:  183:    StringRef Prefix(*Pre);
    10477:  184:    if (Str.startswith(Prefix)) {
     1932:  185:      StringRef Rest = Str.substr(Prefix.size());
    1932*:  186:      bool Matched = IgnoreCase ? Rest.startswith_insensitive(I->Name)
     3864:  187:                                : Rest.startswith(I->Name);
     1932:  188:      if (Matched)
     2082:  189:        return Prefix.size() + StringRef(I->Name).size();
        -:  190:    }
        -:  191:  }
        -:  192:  return 0;
        -:  193:}
        -:  194:
        -:  195:// Returns true if one of the Prefixes + In.Names matches Option
    11040:  196:static bool optionMatches(const OptTable::Info &In, StringRef Option) {
    11040:  197:  if (In.Prefixes) {
    11040:  198:    StringRef InName(In.Name);
    22974:  199:    for (size_t I = 0; In.Prefixes[I]; I++)
    11940:  200:      if (Option.endswith(InName))
       16:  201:        if (Option.slice(0, Option.size() - InName.size()) == In.Prefixes[I])
        6:  202:          return true;
        -:  203:  }
        -:  204:  return false;
        -:  205:}
        -:  206:
        -:  207:// This function is for flag value completion.
        -:  208:// Eg. When "-stdlib=" and "l" was passed to this function, it will return
        -:  209:// appropiriate values for stdlib, which starts with l.
        -:  210:std::vector<std::string>
    #####:  211:OptTable::suggestValueCompletions(StringRef Option, StringRef Arg) const {
        -:  212:  // Search all options and return possible values.
    #####:  213:  for (size_t I = FirstSearchableIndex, E = OptionInfos.size(); I < E; I++) {
    #####:  214:    const Info &In = OptionInfos[I];
    #####:  215:    if (!In.Values || !optionMatches(In, Option))
    #####:  216:      continue;
        -:  217:
    #####:  218:    SmallVector<StringRef, 8> Candidates;
    #####:  219:    StringRef(In.Values).split(Candidates, ",", -1, false);
        -:  220:
    #####:  221:    std::vector<std::string> Result;
    #####:  222:    for (StringRef Val : Candidates)
    #####:  223:      if (Val.startswith(Arg) && Arg.compare(Val))
    #####:  224:        Result.push_back(std::string(Val));
    #####:  225:    return Result;
    #####:  226:  }
    #####:  227:  return {};
        -:  228:}
        -:  229:
        -:  230:std::vector<std::string>
    #####:  231:OptTable::findByPrefix(StringRef Cur, unsigned int DisableFlags) const {
    #####:  232:  std::vector<std::string> Ret;
    #####:  233:  for (size_t I = FirstSearchableIndex, E = OptionInfos.size(); I < E; I++) {
    #####:  234:    const Info &In = OptionInfos[I];
    #####:  235:    if (!In.Prefixes || (!In.HelpText && !In.GroupID))
    #####:  236:      continue;
    #####:  237:    if (In.Flags & DisableFlags)
    #####:  238:      continue;
        -:  239:
    #####:  240:    for (int I = 0; In.Prefixes[I]; I++) {
    #####:  241:      std::string S = std::string(In.Prefixes[I]) + std::string(In.Name) + "\t";
    #####:  242:      if (In.HelpText)
    #####:  243:        S += In.HelpText;
    #####:  244:      if (StringRef(S).startswith(Cur) && S != std::string(Cur) + "\t")
    #####:  245:        Ret.push_back(S);
    #####:  246:    }
        -:  247:  }
    #####:  248:  return Ret;
        -:  249:}
        -:  250:
    #####:  251:unsigned OptTable::findNearest(StringRef Option, std::string &NearestString,
        -:  252:                               unsigned FlagsToInclude, unsigned FlagsToExclude,
        -:  253:                               unsigned MinimumLength) const {
    #####:  254:  assert(!Option.empty());
        -:  255:
        -:  256:  // Consider each [option prefix + option name] pair as a candidate, finding
        -:  257:  // the closest match.
    #####:  258:  unsigned BestDistance = UINT_MAX;
    #####:  259:  for (const Info &CandidateInfo :
    #####:  260:       ArrayRef<Info>(OptionInfos).drop_front(FirstSearchableIndex)) {
    #####:  261:    StringRef CandidateName = CandidateInfo.Name;
        -:  262:
        -:  263:    // We can eliminate some option prefix/name pairs as candidates right away:
        -:  264:    // * Ignore option candidates with empty names, such as "--", or names
        -:  265:    //   that do not meet the minimum length.
    #####:  266:    if (CandidateName.empty() || CandidateName.size() < MinimumLength)
    #####:  267:      continue;
        -:  268:
        -:  269:    // * If FlagsToInclude were specified, ignore options that don't include
        -:  270:    //   those flags.
    #####:  271:    if (FlagsToInclude && !(CandidateInfo.Flags & FlagsToInclude))
    #####:  272:      continue;
        -:  273:    // * Ignore options that contain the FlagsToExclude.
    #####:  274:    if (CandidateInfo.Flags & FlagsToExclude)
    #####:  275:      continue;
        -:  276:
        -:  277:    // * Ignore positional argument option candidates (which do not
        -:  278:    //   have prefixes).
    #####:  279:    if (!CandidateInfo.Prefixes)
    #####:  280:      continue;
        -:  281:
        -:  282:    // Now check if the candidate ends with a character commonly used when
        -:  283:    // delimiting an option from its value, such as '=' or ':'. If it does,
        -:  284:    // attempt to split the given option based on that delimiter.
    #####:  285:    StringRef LHS, RHS;
    #####:  286:    char Last = CandidateName.back();
    #####:  287:    bool CandidateHasDelimiter = Last == '=' || Last == ':';
    #####:  288:    std::string NormalizedName = std::string(Option);
    #####:  289:    if (CandidateHasDelimiter) {
    #####:  290:      std::tie(LHS, RHS) = Option.split(Last);
    #####:  291:      NormalizedName = std::string(LHS);
    #####:  292:      if (Option.find(Last) == LHS.size())
    #####:  293:        NormalizedName += Last;
        -:  294:    }
        -:  295:
        -:  296:    // Consider each possible prefix for each candidate to find the most
        -:  297:    // appropriate one. For example, if a user asks for "--helm", suggest
        -:  298:    // "--help" over "-help".
    #####:  299:    for (int P = 0;
    #####:  300:         const char *const CandidatePrefix = CandidateInfo.Prefixes[P]; P++) {
    #####:  301:      std::string Candidate = (CandidatePrefix + CandidateName).str();
    #####:  302:      StringRef CandidateRef = Candidate;
    #####:  303:      unsigned Distance =
    #####:  304:          CandidateRef.edit_distance(NormalizedName, /*AllowReplacements=*/true,
        -:  305:                                     /*MaxEditDistance=*/BestDistance);
    #####:  306:      if (RHS.empty() && CandidateHasDelimiter) {
        -:  307:        // The Candidate ends with a = or : delimiter, but the option passed in
        -:  308:        // didn't contain the delimiter (or doesn't have anything after it).
        -:  309:        // In that case, penalize the correction: `-nodefaultlibs` is more
        -:  310:        // likely to be a spello for `-nodefaultlib` than `-nodefaultlib:` even
        -:  311:        // though both have an unmodified editing distance of 1, since the
        -:  312:        // latter would need an argument.
    #####:  313:        ++Distance;
        -:  314:      }
    #####:  315:      if (Distance < BestDistance) {
    #####:  316:        BestDistance = Distance;
    #####:  317:        NearestString = (Candidate + RHS).str();
        -:  318:      }
    #####:  319:    }
    #####:  320:  }
    #####:  321:  return BestDistance;
        -:  322:}
        -:  323:
        6:  324:bool OptTable::addValues(const char *Option, const char *Values) {
    11040:  325:  for (size_t I = FirstSearchableIndex, E = OptionInfos.size(); I < E; I++) {
    11040:  326:    Info &In = OptionInfos[I];
    22080:  327:    if (optionMatches(In, Option)) {
        6:  328:      In.Values = Values;
        6:  329:      return true;
        -:  330:    }
        -:  331:  }
        -:  332:  return false;
        -:  333:}
        -:  334:
        -:  335:// Parse a single argument, return the new argument, and update Index. If
        -:  336:// GroupedShortOptions is true, -a matches "-abc" and the argument in Args will
        -:  337:// be updated to "-bc". This overload does not support
        -:  338:// FlagsToInclude/FlagsToExclude or case insensitive options.
    #####:  339:std::unique_ptr<Arg> OptTable::parseOneArgGrouped(InputArgList &Args,
        -:  340:                                                  unsigned &Index) const {
        -:  341:  // Anything that doesn't start with PrefixesUnion is an input, as is '-'
        -:  342:  // itself.
    #####:  343:  const char *CStr = Args.getArgString(Index);
    #####:  344:  StringRef Str(CStr);
    #####:  345:  if (isInput(PrefixesUnion, Str))
    #####:  346:    return std::make_unique<Arg>(getOption(InputOptionID), Str, Index++, CStr);
        -:  347:
    #####:  348:  const Info *End = OptionInfos.data() + OptionInfos.size();
    #####:  349:  StringRef Name = Str.ltrim(PrefixChars);
    #####:  350:  const Info *Start = std::lower_bound(
    #####:  351:      OptionInfos.data() + FirstSearchableIndex, End, Name.data());
    #####:  352:  const Info *Fallback = nullptr;
    #####:  353:  unsigned Prev = Index;
        -:  354:
        -:  355:  // Search for the option which matches Str.
    #####:  356:  for (; Start != End; ++Start) {
    #####:  357:    unsigned ArgSize = matchOption(Start, Str, IgnoreCase);
    #####:  358:    if (!ArgSize)
    #####:  359:      continue;
        -:  360:
    #####:  361:    Option Opt(Start, this);
    #####:  362:    if (std::unique_ptr<Arg> A =
        -:  363:            Opt.accept(Args, StringRef(Args.getArgString(Index), ArgSize),
    #####:  364:                       /*GroupedShortOption=*/false, Index))
    #####:  365:      return A;
        -:  366:
        -:  367:    // If Opt is a Flag of length 2 (e.g. "-a"), we know it is a prefix of
        -:  368:    // the current argument (e.g. "-abc"). Match it as a fallback if no longer
        -:  369:    // option (e.g. "-ab") exists.
    #####:  370:    if (ArgSize == 2 && Opt.getKind() == Option::FlagClass)
        -:  371:      Fallback = Start;
        -:  372:
        -:  373:    // Otherwise, see if the argument is missing.
    #####:  374:    if (Prev != Index)
    #####:  375:      return nullptr;
        -:  376:  }
    #####:  377:  if (Fallback) {
    #####:  378:    Option Opt(Fallback, this);
        -:  379:    // Check that the last option isn't a flag wrongly given an argument.
    #####:  380:    if (Str[2] == '=')
    #####:  381:      return std::make_unique<Arg>(getOption(UnknownOptionID), Str, Index++,
    #####:  382:                                   CStr);
        -:  383:
    #####:  384:    if (std::unique_ptr<Arg> A = Opt.accept(
    #####:  385:            Args, Str.substr(0, 2), /*GroupedShortOption=*/true, Index)) {
    #####:  386:      Args.replaceArgString(Index, Twine('-') + Str.substr(2));
    #####:  387:      return A;
    #####:  388:    }
        -:  389:  }
        -:  390:
        -:  391:  // In the case of an incorrect short option extract the character and move to
        -:  392:  // the next one.
    #####:  393:  if (Str[1] != '-') {
    #####:  394:    CStr = Args.MakeArgString(Str.substr(0, 2));
    #####:  395:    Args.replaceArgString(Index, Twine('-') + Str.substr(2));
    #####:  396:    return std::make_unique<Arg>(getOption(UnknownOptionID), CStr, Index, CStr);
        -:  397:  }
        -:  398:
    #####:  399:  return std::make_unique<Arg>(getOption(UnknownOptionID), Str, Index++, CStr);
        -:  400:}
        -:  401:
     1039:  402:std::unique_ptr<Arg> OptTable::ParseOneArg(const ArgList &Args, unsigned &Index,
        -:  403:                                           unsigned FlagsToInclude,
        -:  404:                                           unsigned FlagsToExclude) const {
     1039:  405:  unsigned Prev = Index;
     1039:  406:  const char *Str = Args.getArgString(Index);
        -:  407:
        -:  408:  // Anything that doesn't start with PrefixesUnion is an input, as is '-'
        -:  409:  // itself.
     2078:  410:  if (isInput(PrefixesUnion, Str))
    #####:  411:    return std::make_unique<Arg>(getOption(InputOptionID), Str, Index++, Str);
        -:  412:
     1039:  413:  const Info *Start = OptionInfos.data() + FirstSearchableIndex;
     1039:  414:  const Info *End = OptionInfos.data() + OptionInfos.size();
     2078:  415:  StringRef Name = StringRef(Str).ltrim(PrefixChars);
        -:  416:
        -:  417:  // Search for the first next option which could be a prefix.
     1039:  418:  Start = std::lower_bound(Start, End, Name.data());
        -:  419:
        -:  420:  // Options are stored in sorted order, with '\0' at the end of the
        -:  421:  // alphabet. Since the only options which can accept a string must
        -:  422:  // prefix it, we iteratively search for the next option which could
        -:  423:  // be a prefix.
        -:  424:  //
        -:  425:  // FIXME: This is searching much more than necessary, but I am
        -:  426:  // blanking on the simplest way to make it fast. We can solve this
        -:  427:  // problem when we move to TableGen.
     1044:  428:  for (; Start != End; ++Start) {
        -:  429:    unsigned ArgSize = 0;
        -:  430:    // Scan for first option which is a proper prefix.
     9563:  431:    for (; Start != End; ++Start)
    19120:  432:      if ((ArgSize = matchOption(Start, Str, IgnoreCase)))
        -:  433:        break;
     1044:  434:    if (Start == End)
        -:  435:      break;
        -:  436:
     1041:  437:    Option Opt(Start, this);
        -:  438:
     1041:  439:    if (FlagsToInclude && !Opt.hasFlag(FlagsToInclude))
        3:  440:      continue;
     1039:  441:    if (Opt.hasFlag(FlagsToExclude))
        1:  442:      continue;
        -:  443:
        -:  444:    // See if this option matches.
     1038:  445:    if (std::unique_ptr<Arg> A =
     1038:  446:            Opt.accept(Args, StringRef(Args.getArgString(Index), ArgSize),
     1038:  447:                       /*GroupedShortOption=*/false, Index))
     1038:  448:      return A;
        -:  449:
        -:  450:    // Otherwise, see if this argument was missing values.
        2:  451:    if (Prev != Index)
    1036*:  452:      return nullptr;
        -:  453:  }
        -:  454:
        -:  455:  // If we failed to find an option and this arg started with /, then it's
        -:  456:  // probably an input path.
        3:  457:  if (Str[0] == '/')
        3:  458:    return std::make_unique<Arg>(getOption(InputOptionID), Str, Index++, Str);
        -:  459:
    #####:  460:  return std::make_unique<Arg>(getOption(UnknownOptionID), Str, Index++, Str);
        -:  461:}
        -:  462:
        3:  463:InputArgList OptTable::ParseArgs(ArrayRef<const char *> ArgArr,
        -:  464:                                 unsigned &MissingArgIndex,
        -:  465:                                 unsigned &MissingArgCount,
        -:  466:                                 unsigned FlagsToInclude,
        -:  467:                                 unsigned FlagsToExclude) const {
        3:  468:  InputArgList Args(ArgArr.begin(), ArgArr.end());
        -:  469:
        -:  470:  // FIXME: Handle '@' args (or at least error on them).
        -:  471:
        3:  472:  MissingArgIndex = MissingArgCount = 0;
        3:  473:  unsigned Index = 0, End = ArgArr.size();
     1042:  474:  while (Index < End) {
        -:  475:    // Ingore nullptrs, they are response file's EOL markers
    1039*:  476:    if (Args.getArgString(Index) == nullptr) {
    #####:  477:      ++Index;
    #####:  478:      continue;
        -:  479:    }
        -:  480:    // Ignore empty arguments (other things may still take them as arguments).
     1039:  481:    StringRef Str = Args.getArgString(Index);
    1039*:  482:    if (Str == "") {
    #####:  483:      ++Index;
    #####:  484:      continue;
        -:  485:    }
        -:  486:
     1039:  487:    unsigned Prev = Index;
     1039:  488:    std::unique_ptr<Arg> A = GroupedShortOptions
        -:  489:                 ? parseOneArgGrouped(Args, Index)
    1039*:  490:                 : ParseOneArg(Args, Index, FlagsToInclude, FlagsToExclude);
     1039:  491:    assert((Index > Prev || GroupedShortOptions) &&
        -:  492:           "Parser failed to consume argument.");
        -:  493:
        -:  494:    // Check for missing argument error.
     1039:  495:    if (!A) {
    #####:  496:      assert(Index >= End && "Unexpected parser error.");
    #####:  497:      assert(Index - Prev - 1 && "No missing arguments!");
    #####:  498:      MissingArgIndex = Prev;
    #####:  499:      MissingArgCount = Index - Prev - 1;
    #####:  500:      break;
        -:  501:    }
        -:  502:
     1039:  503:    Args.append(A.release());
    1039*:  504:  }
        -:  505:
        3:  506:  return Args;
        -:  507:}
        -:  508:
    #####:  509:InputArgList OptTable::parseArgs(int Argc, char *const *Argv,
        -:  510:                                 OptSpecifier Unknown, StringSaver &Saver,
        -:  511:                                 function_ref<void(StringRef)> ErrorFn) const {
    #####:  512:  SmallVector<const char *, 0> NewArgv;
        -:  513:  // The environment variable specifies initial options which can be overridden
        -:  514:  // by commnad line options.
    #####:  515:  cl::expandResponseFiles(Argc, Argv, EnvVar, Saver, NewArgv);
        -:  516:
    #####:  517:  unsigned MAI, MAC;
    #####:  518:  opt::InputArgList Args = ParseArgs(makeArrayRef(NewArgv), MAI, MAC);
    #####:  519:  if (MAC)
    #####:  520:    ErrorFn((Twine(Args.getArgString(MAI)) + ": missing argument").str());
        -:  521:
        -:  522:  // For each unknwon option, call ErrorFn with a formatted error message. The
        -:  523:  // message includes a suggested alternative option spelling if available.
    #####:  524:  std::string Nearest;
    #####:  525:  for (const opt::Arg *A : Args.filtered(Unknown)) {
    #####:  526:    std::string Spelling = A->getAsString(Args);
    #####:  527:    if (findNearest(Spelling, Nearest) > 1)
    #####:  528:      ErrorFn("unknown argument '" + A->getAsString(Args) + "'");
        -:  529:    else
    #####:  530:      ErrorFn("unknown argument '" + A->getAsString(Args) +
    #####:  531:              "', did you mean '" + Nearest + "'?");
    #####:  532:  }
    #####:  533:  return Args;
    #####:  534:}
        -:  535:
    #####:  536:static std::string getOptionHelpName(const OptTable &Opts, OptSpecifier Id) {
    #####:  537:  const Option O = Opts.getOption(Id);
    #####:  538:  std::string Name = O.getPrefixedName();
        -:  539:
        -:  540:  // Add metavar, if used.
    #####:  541:  switch (O.getKind()) {
        -:  542:  case Option::GroupClass: case Option::InputClass: case Option::UnknownClass:
        -:  543:    llvm_unreachable("Invalid option with help text.");
        -:  544:
    #####:  545:  case Option::MultiArgClass:
    #####:  546:    if (const char *MetaVarName = Opts.getOptionMetaVar(Id)) {
        -:  547:      // For MultiArgs, metavar is full list of all argument names.
    #####:  548:      Name += ' ';
    #####:  549:      Name += MetaVarName;
        -:  550:    }
        -:  551:    else {
        -:  552:      // For MultiArgs<N>, if metavar not supplied, print <value> N times.
    #####:  553:      for (unsigned i=0, e=O.getNumArgs(); i< e; ++i) {
    #####:  554:        Name += " <value>";
        -:  555:      }
        -:  556:    }
        -:  557:    break;
        -:  558:
        -:  559:  case Option::FlagClass:
        -:  560:    break;
        -:  561:
        -:  562:  case Option::ValuesClass:
        -:  563:    break;
        -:  564:
    #####:  565:  case Option::SeparateClass: case Option::JoinedOrSeparateClass:
    #####:  566:  case Option::RemainingArgsClass: case Option::RemainingArgsJoinedClass:
    #####:  567:    Name += ' ';
    #####:  568:    LLVM_FALLTHROUGH;
    #####:  569:  case Option::JoinedClass: case Option::CommaJoinedClass:
    #####:  570:  case Option::JoinedAndSeparateClass:
    #####:  571:    if (const char *MetaVarName = Opts.getOptionMetaVar(Id))
    #####:  572:      Name += MetaVarName;
        -:  573:    else
    #####:  574:      Name += "<value>";
        -:  575:    break;
        -:  576:  }
        -:  577:
    #####:  578:  return Name;
        -:  579:}
        -:  580:
        -:  581:namespace {
    #####:  582:struct OptionInfo {
        -:  583:  std::string Name;
        -:  584:  StringRef HelpText;
        -:  585:};
        -:  586:} // namespace
        -:  587:
    #####:  588:static void PrintHelpOptionList(raw_ostream &OS, StringRef Title,
        -:  589:                                std::vector<OptionInfo> &OptionHelp) {
    #####:  590:  OS << Title << ":\n";
        -:  591:
        -:  592:  // Find the maximum option length.
    #####:  593:  unsigned OptionFieldWidth = 0;
    #####:  594:  for (const OptionInfo &Opt : OptionHelp) {
        -:  595:    // Limit the amount of padding we are willing to give up for alignment.
    #####:  596:    unsigned Length = Opt.Name.size();
    #####:  597:    if (Length <= 23)
    #####:  598:      OptionFieldWidth = std::max(OptionFieldWidth, Length);
        -:  599:  }
        -:  600:
        -:  601:  const unsigned InitialPad = 2;
    #####:  602:  for (const OptionInfo &Opt : OptionHelp) {
    #####:  603:    const std::string &Option = Opt.Name;
    #####:  604:    int Pad = OptionFieldWidth - int(Option.size());
    #####:  605:    OS.indent(InitialPad) << Option;
        -:  606:
        -:  607:    // Break on long option names.
    #####:  608:    if (Pad < 0) {
    #####:  609:      OS << "\n";
    #####:  610:      Pad = OptionFieldWidth + InitialPad;
        -:  611:    }
    #####:  612:    OS.indent(Pad + 1) << Opt.HelpText << '\n';
        -:  613:  }
    #####:  614:}
        -:  615:
    #####:  616:static const char *getOptionHelpGroup(const OptTable &Opts, OptSpecifier Id) {
    #####:  617:  unsigned GroupID = Opts.getOptionGroupID(Id);
        -:  618:
        -:  619:  // If not in a group, return the default help group.
    #####:  620:  if (!GroupID)
        -:  621:    return "OPTIONS";
        -:  622:
        -:  623:  // Abuse the help text of the option groups to store the "help group"
        -:  624:  // name.
        -:  625:  //
        -:  626:  // FIXME: Split out option groups.
    #####:  627:  if (const char *GroupHelp = Opts.getOptionHelpText(GroupID))
        -:  628:    return GroupHelp;
        -:  629:
        -:  630:  // Otherwise keep looking.
    #####:  631:  return getOptionHelpGroup(Opts, GroupID);
        -:  632:}
        -:  633:
    #####:  634:void OptTable::printHelp(raw_ostream &OS, const char *Usage, const char *Title,
        -:  635:                         bool ShowHidden, bool ShowAllAliases) const {
    #####:  636:  printHelp(OS, Usage, Title, /*Include*/ 0, /*Exclude*/
        -:  637:            (ShowHidden ? 0 : HelpHidden), ShowAllAliases);
    #####:  638:}
        -:  639:
    #####:  640:void OptTable::printHelp(raw_ostream &OS, const char *Usage, const char *Title,
        -:  641:                         unsigned FlagsToInclude, unsigned FlagsToExclude,
        -:  642:                         bool ShowAllAliases) const {
    #####:  643:  OS << "OVERVIEW: " << Title << "\n\n";
    #####:  644:  OS << "USAGE: " << Usage << "\n\n";
        -:  645:
        -:  646:  // Render help text into a map of group-name to a list of (option, help)
        -:  647:  // pairs.
    #####:  648:  std::map<std::string, std::vector<OptionInfo>> GroupedOptionHelp;
        -:  649:
    #####:  650:  for (unsigned Id = 1, e = getNumOptions() + 1; Id != e; ++Id) {
        -:  651:    // FIXME: Split out option groups.
    #####:  652:    if (getOptionKind(Id) == Option::GroupClass)
    #####:  653:      continue;
        -:  654:
    #####:  655:    unsigned Flags = getInfo(Id).Flags;
    #####:  656:    if (FlagsToInclude && !(Flags & FlagsToInclude))
    #####:  657:      continue;
    #####:  658:    if (Flags & FlagsToExclude)
    #####:  659:      continue;
        -:  660:
        -:  661:    // If an alias doesn't have a help text, show a help text for the aliased
        -:  662:    // option instead.
    #####:  663:    const char *HelpText = getOptionHelpText(Id);
    #####:  664:    if (!HelpText && ShowAllAliases) {
    #####:  665:      const Option Alias = getOption(Id).getAlias();
    #####:  666:      if (Alias.isValid())
    #####:  667:        HelpText = getOptionHelpText(Alias.getID());
        -:  668:    }
        -:  669:
    #####:  670:    if (HelpText && (strlen(HelpText) != 0)) {
    #####:  671:      const char *HelpGroup = getOptionHelpGroup(*this, Id);
    #####:  672:      const std::string &OptName = getOptionHelpName(*this, Id);
    #####:  673:      GroupedOptionHelp[HelpGroup].push_back({OptName, HelpText});
    #####:  674:    }
        -:  675:  }
        -:  676:
    #####:  677:  for (auto& OptionGroup : GroupedOptionHelp) {
    #####:  678:    if (OptionGroup.first != GroupedOptionHelp.begin()->first)
    #####:  679:      OS << "\n";
    #####:  680:    PrintHelpOptionList(OS, OptionGroup.first, OptionGroup.second);
        -:  681:  }
        -:  682:
    #####:  683:  OS.flush();
    #####:  684:}
